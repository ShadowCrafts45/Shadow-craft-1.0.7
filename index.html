<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Shadow-craft ‚Äî Infinite Chunked World Core</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    html,body { height:100%; margin:0; background:#111; overflow:hidden; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; -webkit-user-select:none; user-select:none; touch-action:none; }
    #hud { position:fixed; left:12px; top:12px; z-index:60; background:rgba(0,0,0,0.45); color:#fff; padding:10px 12px; border-radius:8px; font-family: monospace; font-size:13px; max-width:46%; }
    #hint { position:fixed; left:50%; transform:translateX(-50%); bottom:14px; z-index:50; color:#fff; background:rgba(0,0,0,0.35); padding:8px 12px; border-radius:8px; font-size:13px; }
    #controls-ui { position:fixed; left:0; right:0; bottom:0; display:flex; justify-content:space-between; padding:12px; z-index:45; pointer-events:none; }
    #joy-left { width:140px; height:140px; margin-left:12px; pointer-events:auto; touch-action:none; position:relative; }
    .joy-bg { width:100%; height:100%; background:rgba(255,255,255,0.04); border-radius:50%; border:1px solid rgba(255,255,255,0.08); display:flex; align-items:center; justify-content:center; }
    .joy-knob { width:48px; height:48px; background:rgba(255,255,255,0.14); border-radius:50%; transform:translate(-50%,-50%); position:absolute; left:50%; top:50%; pointer-events:none; display:flex; align-items:center; justify-content:center; color:#fff; font-size:14px; }
    #right-controls { margin-right:12px; display:flex; flex-direction:column; gap:10px; pointer-events:none; align-items:flex-end; }
    #start-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(-45deg, #0f0f0f, #1a1a1a, #222, #0f0f0f);
      background-size: 400% 400%;
      animation: gradientShift 12s ease infinite;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
    }
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    #look-area {
      position: fixed;
      top: 0;
      right: 0;
      width: 50%;
      height: calc(100% - 120px);
      background: rgba(255,255,255,0.02);
      touch-action: none;
      pointer-events: auto;
      z-index: 40;
    }
    #button-stack {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      pointer-events: auto;
      z-index: 50;
    }
    .action-row {
      display: flex;
      gap: 10px;
      justify-content: center;
      pointer-events: auto;
    }
    .btn { width:56px; height:56px; background:rgba(255,255,255,0.06); border-radius:12px; border:1px solid rgba(255,255,255,0.12); color:#fff; font-size:20px; display:flex; align-items:center; justify-content:center; user-select:none; touch-action:manipulation; pointer-events: auto; transition: transform 0.1s ease;}
    #hotbar { position:fixed; left:50%; transform:translateX(-50%); bottom:84px; z-index:55; display:flex; gap:8px; pointer-events:none; }
    .hotbar-slot { pointer-events:auto; width:64px; height:64px; background:rgba(0,0,0,0.6); border-radius:8px; border:2px solid rgba(255,255,255,0.08); display:flex; flex-direction:column; align-items:center; justify-content:center; color:#fff; font-size:12px; cursor:pointer; box-sizing:border-box; transition: transform 0.1s ease; }
    .hotbar-slot .icon { width:36px; height:36px; border-radius:6px; margin-bottom:6px; background-size:cover; background-position:center; box-shadow: inset 0 -6px 12px rgba(0,0,0,0.25); }
    .hotbar-slot .count { font-size:11px; opacity:0.9; }
    .hotbar-slot.selected { border-color: #ffd36b; box-shadow: 0 0 12px rgba(255,211,107,0.18); transform:translateY(-4px); }
    #progress { position:fixed; left:50%; transform:translateX(-50%); bottom:156px; z-index:68; width:260px; height:14px; background:rgba(255,255,255,0.06); border-radius:8px; overflow:hidden; display:none }
    #progress > div { height:100%; width:0%; background:linear-gradient(90deg,#ffd36b,#ff8a3d); border-radius:8px; transition: width 0.1s linear; }
    @media (pointer: fine) { #controls-ui { display:none; } }
    @media (max-width: 420px) {
      #crosshair { font-size: 20px; }
      #look-area { width: 220px; height: 360px; }
      #joy-left { width: 100px; height: 100px; }
      .btn { width: 44px; height: 44px; font-size: 18px; }
      .hotbar-slot { width: 48px; height: 48px; font-size: 10px; }
      .hotbar-slot .icon { width: 28px; height: 28px; margin-bottom: 4px; }
      .hotbar-slot .count { font-size: 9px; }
      #inventory-grid { grid-template-columns: repeat(9, 48px); gap: 6px; }
      .inventory-slot { width: 48px; height: 48px; font-size: 10px; }
      .inventory-slot .icon { width: 28px; height: 28px; margin-bottom: 2px; }
    }
    
    canvas { display:block; }
    #inventory-panel {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      padding: 20px;
      border-radius: 12px;
      z-index: 70;
      display: none;
    }
    #inventory-grid {
      display: grid;
      grid-template-columns: repeat(9, 64px);
      gap: 8px;
    }
    .inventory-slot {
      width: 64px;
      height: 64px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 12px;
    }
    .inventory-slot .icon {
      width: 36px;
      height: 36px;
      margin-bottom: 4px;
      background-size: cover;
      background-position: center;
    }
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 28px;
      color: rgba(255,255,255,0.85);
      z-index: 65;
      pointer-events: none;
      user-select: none;
    }
    #leave-world-button {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 100;
      padding: 10px 18px;
      font-size: 16px;
      background: linear-gradient(90deg, #ff8a3d, #ffd36b);
      color: #000;
      border: none;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: none; /* Hide until game starts */
    }
    #leave-world-button:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    #world-select {
      padding: 10px 14px;
      font-size: 16px;
      border-radius: 8px;
      border: none;
      background: rgba(255,255,255,0.1);
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      margin-bottom: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      outline: none;
    }
    #world-select option {
      background: #222;
      color: #fff;
    }
    #load-world-button,
    #new-world-button {
      padding: 10px 18px;
      font-size: 16px;
      background: #ffd36b;
      color: #000;
      border: none;
      border-radius: 10px;
      box-shadow: 0 0 12px rgba(255,211,107,0.4);
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    #load-world-button:hover,
    #new-world-button:hover {
      transform: scale(1.08);
      box-shadow: 0 0 20px rgba(255,211,107,0.6);
    }
    #confirm-box {
      background: #222;
      padding: 20px 30px;
      border-radius: 12px;
      text-align: center;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      box-shadow: 0 44px 12px rgba(0,0,0,0.4);
    }
    #confirm-box p {
      font-size: 18px;
      margin-bottom: 20px;
    }
    #confirm-box button {
      padding: 10px 18px;
      font-size: 16px;
      margin: 0 10px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.2s ease;
    }
    #confirm-leave-button {
      background: linear-gradient(90deg, #ffd36b, #ff8a3d);
      color: #000;
    }
    #cancel-leave-button {
      background: #555;
      color: #fff;
    }
    #confirm-box button:hover {
      transform: scale(1.05);
    }
    #game-title {
      font-size: 48px;
      color: #ffd36b;
      text-shadow: 0 0 12px rgba(255,211,107,0.4);
      animation: floatTitle 4s ease-in-out infinite;
    }
    @keyframes floatTitle {
      0% { transform: translateY(0); }
      50% { transform: translateY(-6px); }
      100% { transform: translateY(0); }
    }
    #particle-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      z-index: 99;
      background-image: radial-gradient(circle, rgba(255,255,255,0.05) 1px, transparent 1px);
      background-size: 20px 20px;
      animation: particleDrift 30s linear infinite;
    }
    @keyframes particleDrift {
      0% { background-position: 0 0; }
      100% { background-position: 100px 100px; }
    }
    #tutorial-box {
      animation: fadeIn 2s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    #toggle-tutorial-button {
      padding: 10px 18px;
      font-size: 16px;
      background: linear-gradient(90deg, #6bcaff, #3d9eff);
      color: #000;
      border: none;
      border-radius: 10px;
      box-shadow: 0 0 12px rgba(107,202,255,0.4);
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    #toggle-tutorial-button:hover {
      transform: scale(1.08);
      box-shadow: 0 0 20px rgba(107,202,255,0.6);
    }
    #confirm-leave {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    #tutorial-box {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.85);
      padding: 16px 20px;
      border-radius: 12px;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      font-size: 14px;
      max-width: 320px;
      z-index: 150;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      animation: fadeIn 0.5s ease-out;
    }
    .floating-btn {
      position: fixed;
      top: 12px;
      z-index: 80;
      padding: 8px 14px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .floating-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    #floating-save-button {
      left: 12px;
      background: linear-gradient(90deg, #aaaaaa, #666666);
      color: #fff;
      display: none; /* Hide until game starts */
    }
    #download-screenshot-button {
      left: 120px;
      background: linear-gradient(90deg, #b2f8a8, #5ed64c);
      color: #000;
      display: none; /* Hide until game starts */
    }
    #btn-jump:active, #btn-toggle-view:active, #btn-break:active:active, #btn-place:active, #btn-inventory:active {
      transform: scale(0.9);
    }
    @media (min-width: 768px) { #look-area { display: none; } }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
</head>
<body>
  <div id="particle-overlay"></div>
  <div id="start-screen">
    <h1 id="game-title">Shadow-craft</h1>
    <select id="world-select"></select>
    <div style="display: flex; gap: 12px; margin-top: 12px;">
      <button id="load-world-button">‚ñ∂Ô∏è Load World</button>
      <button id="new-world-button">üåç Create New World</button>
      <button id="toggle-tutorial-button">üìò Tutorial</button>
    </div>
  </div>
  <button id="floating-save-button" class="floating-btn" disabled>üíæ Save (Disabled)</button>
  <button id="download-screenshot-button" class="floating-btn">üñºÔ∏è Screenshot</button>
  
  <div id="tutorial-box" style="display:none;">
    <h2>üïπÔ∏è How to Play</h2>
    <div class="tutorial-section">
      <h3>üíª PC Controls</h3>
      <ul>
        <li><b>WASD</b> ‚Äî Move</li>
        <li><b>Space</b> ‚Äî Jump</li>
        <li><b>Left Click</b> ‚Äî Break block</li>
        <li><b>Right Click / E</b> ‚Äî Place block</li>
        <li><b>V</b> ‚Äî Toggle First/Third Person View</li>
        <li><b>I</b> ‚Äî Open inventory</li>
        <li><b>1‚Äì8</b> ‚Äî Select block</li>
        <li><b>Click</b> ‚Äî Lock pointer</li>
      </ul>
    </div>
    <div class="tutorial-section">
      <h3>üì± Mobile Controls</h3>
      <ul>
        <li><b>Left joystick</b> ‚Äî Move</li>
        <li><b>Right drag</b> ‚Äî Look around</li>
        <li><b>‚è´</b> ‚Äî Jump</li>
        <li><b>‚õè</b> ‚Äî Break block</li>
        <li><b>üß±</b> ‚Äî Place block</li>
        <li><b>üéí</b> ‚Äî Open inventory</li>
        <li><b>üëÅÔ∏è</b> ‚Äî Toggle view (1st/3rd person)</li>
      </ul>
    </div>
  </div>
  
  <button id="leave-world-button">‚èπ Leave World</button>
  <div id="confirm-leave" style="display:none;">
    <div id="confirm-box">
      <p>Are you sure you want to leave this world?</p>
      <div class="confirm-buttons">
        <button id="confirm-leave-button">‚úÖ Yes, Leave</button>
        <button id="cancel-leave-button">‚ùå Cancel</button>
      </div>
    </div>
  </div>
  
  <div id="hud" style="display:none;"></div>
  <div id="hint" style="display:none;"></div>
  <div id="crosshair">+</div>
  
  <div id="controls-ui" aria-hidden="true" style="display:none;">
    <div id="joy-left" aria-hidden="true"><div class="joy-bg"></div><div class="joy-knob" id="joy-knob">‚Ä¢</div></div>
    <div id="right-controls" aria-hidden="true">
      <div id="look-area" title="Drag here to look (mobile)"></div>
      <div id="button-stack">
        <div class="btn" id="btn-jump">‚è´</div>
        <div class="btn" id="btn-toggle-view">üëÅÔ∏è</div>
        <div class="action-row">
          <div class="btn" id="btn-break">‚õè</div>
          <div class="btn" id="btn-place">üß±</div>
          <div class="btn" id="btn-inventory">üéí</div>
        </div>
      </div>
    </div>
  </div>
  <div id="hotbar"></div>
  <div id="inventory-panel" style="display:none;">
    <div id="inventory-grid"></div>
  </div>
  <div id="progress"><div></div></div>

  <script>
    // Note: The original module import was removed to use the global THREE from the CDN script tag.
    
    // --- Configuration Constants ---

    // Game settings
    const CHUNK_SIZE = 16;
    const WORLD_HEIGHT = 16;
    const RENDER_DISTANCE = 3; // Number of chunks to render in each direction (X and Z)
    const COLLISION_MARGIN = 0.15;
    const COOLDOWN_MS = 200; // Block placement cooldown
    const THIRD_PERSON_DISTANCE = 3.5;

    // Physics parameters (ADJUSTED FOR STABILITY)
    const MAX_SPEED = 0.12;
    const JUMP_VELOCITY = 0.25;
    const GRAVITY = 0.035; 
    const FRICTION = 0.95; 
    const AIR_DRAG = 0.98;

    // Block definitions (Using the detailed set for proper meshing/texturing)
    const BLOCK_AIR = 0;
    const BLOCK_GRASS = 1;
    const BLOCK_DIRT = 2;
    const BLOCK_STONE = 3;
    const BLOCK_WOOD = 4;
    const BLOCK_LEAVES = 5;
    const BLOCK_WATER = 6;
    const BLOCK_SAND = 7;
    const BLOCK_GLASS = 8;
    const BLOCK_BRICK = 9;
    const BLOCK_GOLD = 10;
    
    // Detailed Block Definitions for Meshing/Texturing
    const BLOCKS = {
      [BLOCK_AIR]: { name: "Air", solid: false, emissive: 0x000000, color: 0x000000, top: 0, side: 0, bottom: 0, preview: '' },
      [BLOCK_GRASS]: { name: "Grass", solid: true, color: 0x4c753b, top: 1, side: 2, bottom: 3, preview: 'üåø' },
      [BLOCK_DIRT]: { name: "Dirt", solid: true, color: 0x7a5b46, top: 3, side: 3, bottom: 3, preview: 'üü´' },
      [BLOCK_STONE]: { name: "Stone", solid: true, color: 0x7f8c8d, top: 4, side: 4, bottom: 4, preview: '‚ö´' },
      [BLOCK_WOOD]: { name: "Wood", solid: true, color: 0x8a6f4e, top: 5, side: 5, bottom: 5, preview: 'ü™µ' },
      [BLOCK_LEAVES]: { name: "Leaves", solid: true, color: 0x27ae60, top: 6, side: 6, bottom: 6, preview: 'üçÉ' },
      [BLOCK_WATER]: { name: "Water", solid: false, color: 0x3498db, top: 7, side: 7, bottom: 7, preview: 'üíß' },
      [BLOCK_SAND]: { name: "Sand", solid: true, color: 0xf7dc6f, top: 8, side: 8, bottom: 8, preview: 'üü°' },
      [BLOCK_GLASS]: { name: "Glass", solid: false, color: 0xbbbbbb, top: 9, side: 9, bottom: 9, preview: 'ü™ü' },
      [BLOCK_BRICK]: { name: "Brick", solid: true, color: 0xc0392b, top: 10, side: 10, bottom: 10, preview: 'üß±' },
      [BLOCK_GOLD]: { name: "Gold", solid: true, color: 0xffc300, top: 10, side: 10, bottom: 10, preview: '‚ú®' },
    };

    const TEXTURE_SIZE = 16;
    const ATLAS_SIZE = 11; // 11 textures defined (0 to 10)

    // --- Utility Functions & Data Structures ---
    
    // Use the THREE object now available globally
    const Vector3 = THREE.Vector3;

    function getChunkPos(x, y, z) {
      // Calculate which chunk coordinate the world coordinate (x,y,z) belongs to
      return {
        cx: Math.floor(x / CHUNK_SIZE),
        cy: Math.floor(y / CHUNK_SIZE),
        cz: Math.floor(z / CHUNK_SIZE)
      };
    }
    
    // --- Player Skin/Model (Placeholder) ---
    function makePlayerSkinCanvas() {
        const size = 64;
        const c = document.createElement('canvas'); c.width = c.height = size;
        const ctx = c.getContext('2d');
        ctx.fillStyle = '#ff7f50'; // Coral Skin
        ctx.fillRect(0, 0, size, size);
        ctx.fillStyle = '#000000';
        ctx.fillRect(size/8, size/8, size/4, size/4); // Left eye
        ctx.fillRect(5*size/8, size/8, size/4, size/4); // Right eye
        return c;
    }
    
    let playerModel;
    function createPlayerModel() {
      const skinCanvas = makePlayerSkinCanvas();
      const skinTexture = new THREE.CanvasTexture(skinCanvas);
      skinTexture.magFilter = THREE.NearestFilter;

      const mat = new THREE.MeshBasicMaterial({ map: skinTexture, side: THREE.DoubleSide });

      const group = new THREE.Group();

      const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), mat);
      head.position.set(0, 1.8, 0); group.add(head);

      const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.6), mat);
      torso.position.set(0, 0.9, 0); group.add(torso);

      const armL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), mat);
      armL.position.set(-0.65, 0.9, 0); group.add(armL);

      const armR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), mat);
      armR.position.set(0.65, 0.9, 0); group.add(armR);

      const legL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.4), mat);
      legL.position.set(-0.25, 0.0, 0); group.add(legL);

      const legR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.4), mat);
      legR.position.set(0.25, 0.0, 0); group.add(legR);
      
      playerModel = group;
      return group;
    }

  // --- World Data Structure (from previous file) ---

    class World {
      constructor() {
        this.chunks = {};
        this.chunkMeshes = {};
        this.scene = new THREE.Group();
      }

      get(x, y, z) {
        if (!this.inBounds(x, y, z)) return BLOCK_AIR;
        const { cx, cy, cz } = getChunkPos(x, y, z);
        const chunkKey = `${cx},${cy},${cz}`;
        const chunk = this.chunks[chunkKey];

        if (chunk) {
          // Local coordinates within the chunk (0 to CHUNK_SIZE-1)
          const lx = (x % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE; // Use modulo with wrap for negative coordinates
          const ly = (y % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE; 
          const lz = (z % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE; 
          
          return chunk[ly * CHUNK_SIZE * CHUNK_SIZE + lz * CHUNK_SIZE + lx];
        }
        return BLOCK_AIR;
      }

      set(x, y, z, blockId) {
        if (!this.inBounds(x, y, z)) return;
        const { cx, cy, cz } = getChunkPos(x, y, z);
        const chunkKey = `${cx},${cy},${cz}`;

        let chunk = this.chunks[chunkKey];
        if (!chunk) {
          chunk = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE).fill(BLOCK_AIR);
          this.chunks[chunkKey] = chunk;
        }

        const lx = (x % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
        const ly = (y % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
        const lz = (z % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
        chunk[ly * CHUNK_SIZE * CHUNK_SIZE + lz * CHUNK_SIZE + lx] = blockId;
        this.updateChunkMesh(cx, cy, cz);

        // Update neighbors' meshes if the change was on a chunk boundary
        if (lx === 0) this.updateChunkMesh(cx - 1, cy, cz);
        if (lx === CHUNK_SIZE - 1) this.updateChunkMesh(cx + 1, cy, cz);
        if (ly === 0) this.updateChunkMesh(cx, cy - 1, cz);
        if (ly === CHUNK_SIZE - 1) this.updateChunkMesh(cx, cy + 1, cz);
        if (lz === 0) this.updateChunkMesh(cx, cy, cz - 1);
        if (lz === CHUNK_SIZE - 1) this.updateChunkMesh(cx, cy, cz + 1);
      }

      inBounds(x, y, z) {
        // Simple height bound check (only 1 layer of chunks in Y for simplicity)
        return y >= 0 && y < CHUNK_SIZE * WORLD_HEIGHT;
      }

      // Simple Perlin Noise for terrain generation
      generateTerrain(cx, cz) {
        // Check if the base chunk (cy=0) already exists
        const chunkKey = `${cx},0,${cz}`;
        if (this.chunks[chunkKey]) return;

        const seed = 1337;
        const noise = (x, y) => {
          // Simple procedural noise function
          const s = 0.05;
          const h1 = Math.sin(x * s + seed) * Math.cos(y * s + seed) * 0.5 + 0.5;
          const h2 = Math.sin(x * s * 2 + seed + 100) * Math.cos(y * s * 2 + seed + 100) * 0.25 + 0.25;
          return (h1 * 0.5 + h2 * 0.5) * 0.5 + 0.5;
        };

        const chunk = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE).fill(BLOCK_AIR);
        const chunkOffsetX = cx * CHUNK_SIZE;
        const chunkOffsetZ = cz * CHUNK_SIZE;

        for (let x = 0; x < CHUNK_SIZE; x++) {
          for (let z = 0; z < CHUNK_SIZE; z++) {
            const worldX = chunkOffsetX + x;
            const worldZ = chunkOffsetZ + z;
            // Scale noise to a height between 0 and CHUNK_SIZE * WORLD_HEIGHT * 0.6
            const height = Math.floor(noise(worldX, worldZ) * CHUNK_SIZE * WORLD_HEIGHT * 0.6); 

            for (let y = 0; y < CHUNK_SIZE; y++) {
              const worldY = 0 * CHUNK_SIZE + y; // Assuming cy=0
              const index = y * CHUNK_SIZE * CHUNK_SIZE + z * CHUNK_SIZE + x;

              if (worldY < height && worldY >= 0) {
                if (worldY === height - 1) {
                  chunk[index] = BLOCK_GRASS;
                } else if (worldY > height - 5) {
                  chunk[index] = BLOCK_DIRT;
                } else {
                  chunk[index] = BLOCK_STONE;
                }
              }
            }
          }
        }
        this.chunks[chunkKey] = chunk;
        this.updateChunkMesh(cx, 0, cz);
      }

      updateChunkMesh(cx, cy, cz) {
        const chunkKey = `${cx},${cy},${cz}`;
        const chunk = this.chunks[chunkKey];
        
        // Remove old mesh if it exists
        if (this.chunkMeshes[chunkKey]) {
          this.scene.remove(this.chunkMeshes[chunkKey]);
        }

        if (!chunk) return;

        const mergedGeometry = new THREE.BufferGeometry();
        const positions = [];
        const normals = [];
        const uvs = [];
        const colors = [];

        const neighborOffsets = [
          [0, 0, 1, 0, 0, 1], // Z+ (front)
          [0, 0, -1, 0, 0, -1], // Z- (back)
          [1, 0, 0, 1, 0, 0], // X+ (right)
          [-1, 0, 0, -1, 0, 0], // X- (left)
          [0, 1, 0, 0, 1, 0], // Y+ (top)
          [0, -1, 0, 0, -1, 0], // Y- (bottom)
        ];

        // Vertices for a unit cube
        const v = [
          [0, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0],
          [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]
        ];

        // Faces definitions (indices of vertices for each face)
        const faces = [
          [4, 5, 6, 7], // Z+
          [3, 2, 1, 0], // Z-
          [7, 6, 2, 3], // X+
          [0, 1, 5, 4], // X-
          [1, 2, 6, 5], // Y+
          [0, 3, 7, 4]  // Y-
        ];

        for (let y = 0; y < CHUNK_SIZE; y++) {
          for (let z = 0; z < CHUNK_SIZE; z++) {
            for (let x = 0; x < CHUNK_SIZE; x++) {
              const blockId = chunk[y * CHUNK_SIZE * CHUNK_SIZE + z * CHUNK_SIZE + x];
              if (blockId === BLOCK_AIR) continue;

              const block = BLOCKS[blockId];
              const blockColor = new THREE.Color(block.color);
              const worldX = cx * CHUNK_SIZE + x;
              const worldY = cy * CHUNK_SIZE + y;
              const worldZ = cz * CHUNK_SIZE + z;

              // Check 6 faces for culling
              for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
                const [ox, oy, oz] = neighborOffsets[faceIndex].slice(0, 3);
                const neighborBlockId = this.get(worldX + ox, worldY + oy, worldZ + oz);
                const neighborBlock = BLOCKS[neighborBlockId];

                // Face Culling: Render face if neighbor is not solid or is a transparent/fluid block
                const isSolidNeighbor = neighborBlock.solid;
                const isSameBlock = neighborBlockId === blockId;

                if (neighborBlockId === BLOCK_AIR || neighborBlockId === BLOCK_WATER || neighborBlockId === BLOCK_GLASS || !isSolidNeighbor || !isSameBlock) {

                  const face = faces[faceIndex];
                  // Use the texture IDs defined in BLOCKS (top, side, bottom)
                  const textureId = [block.side, block.side, block.side, block.side, block.top, block.bottom][faceIndex];

                  // Calculate texture UVs from the atlas
                  const tx_start = (textureId % ATLAS_SIZE) / ATLAS_SIZE;
                  const ty_start = Math.floor(textureId / ATLAS_SIZE) / ATLAS_SIZE;
                  const tx_end = tx_start + (1 / ATLAS_SIZE);
                  const ty_end = ty_start + (1 / ATLAS_SIZE);

                  const uvData = [
                    tx_start, ty_end, // v0 (bottom-left)
                    tx_start, ty_start, // v1 (top-left)
                    tx_end, ty_start, // v2 (top-right)
                    tx_end, ty_end  // v3 (bottom-right)
                  ];

                  // Add 4 vertices for the quad
                  const quadVertices = [];
                  for (let i = 0; i < 4; i++) {
                    const vertexIndex = face[i];
                    const vx = x + v[vertexIndex][0];
                    const vy = y + v[vertexIndex][1];
                    const vz = z + v[vertexIndex][2];
                    quadVertices.push(vx, vy, vz);

                    normals.push(ox, oy, oz);

                    // Add color (slight darkening for the bottom face)
                    const colorIntensity = (faceIndex === 5) ? 0.9 : 1.0;
                    colors.push(blockColor.r * colorIntensity, blockColor.g * colorIntensity, blockColor.b * colorIntensity);
                  }

                  // Positions are added based on the face definition (v0-v3)
                  positions.push(
                    quadVertices[0], quadVertices[1], quadVertices[2],
                    quadVertices[3], quadVertices[4], quadVertices[5],
                    quadVertices[6], quadVertices[7], quadVertices[8],
                    quadVertices[9], quadVertices[10], quadVertices[11]
                  );
                  
                  // Add 4 UVs for the quad
                  uvs.push(...uvData);
                }
              }
            }
          }
        }

        // Finalize geometry buffers
        mergedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        mergedGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        mergedGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        mergedGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        mergedGeometry.computeBoundingSphere();

        // Use MeshBasicMaterial with vertexColors for robust rendering
        const mesh = new THREE.Mesh(
          mergedGeometry,
          new THREE.MeshBasicMaterial({
            vertexColors: true,
            map: texture,
            transparent: true, 
            alphaTest: 0.1, 
          })
        );
        mesh.position.set(cx * CHUNK_SIZE, cy * CHUNK_SIZE, cz * CHUNK_SIZE);
        this.chunkMeshes[chunkKey] = mesh;
        this.scene.add(mesh);
      }

      /**
       * The core of infinite generation: loads and unloads chunks based on player position.
       */
      updateMeshes() {
        // Get the chunk coordinates the player is currently in
        const { cx: pcx, cz: pcz } = getChunkPos(player.pos.x, player.pos.y, player.pos.z);
        const keysToKeep = new Set();

        // Iterate through the render distance grid around the player
        for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
          for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
            const cx = pcx + x;
            const cz = pcz + z;
            const cy = 0; // Only generate/render the base chunk layer

            const chunkKey = `${cx},${cy},${cz}`;
            keysToKeep.add(chunkKey);

            if (!this.chunks[chunkKey]) {
              // Generate chunk if it doesn't exist
              this.generateTerrain(cx, cz);
            }
          }
        }

        // Clean up distant chunks that are no longer within RENDER_DISTANCE
        for (const key in this.chunkMeshes) {
          if (!keysToKeep.has(key)) {
            this.scene.remove(this.chunkMeshes[key]);
            delete this.chunkMeshes[key];
            delete this.chunks[key];
          }
        }
      }
    }


    // --- Player State and Input (from previous file) ---

    const player = {
      pos: new Vector3(0, CHUNK_SIZE * WORLD_HEIGHT * 0.7, 0),
      vel: new Vector3(0, 0, 0),
      height: 1.8,
      width: 0.6,
      onGround: false,
    };

    const inputState = {
      forward: false, back: false, left: false, right: false, up: false, down: false,
      jump: false,
      break: false, place: false,
      cursorLocked: false,
    };

    let selectedBlockId = BLOCK_GRASS;
    let inventory = {
      [BLOCK_GRASS]: 64, [BLOCK_DIRT]: 64, [BLOCK_STONE]: 64, [BLOCK_WOOD]: 64,
      [BLOCK_LEAVES]: 64, [BLOCK_WATER]: 0, [BLOCK_SAND]: 64, [BLOCK_GLASS]: 64,
      [BLOCK_BRICK]: 64, [BLOCK_GOLD]: 64
    };
    
    let allowPlacing = true;
    let placeTimer = 0;
    let thirdPerson = false;
    let gameStarted = false;


    // --- Texture Atlas Setup (from previous file) ---

    const canvas = document.createElement('canvas');
    canvas.width = TEXTURE_SIZE * ATLAS_SIZE;
    canvas.height = TEXTURE_SIZE;
    const ctx = canvas.getContext('2d');

    // Create a 16x16 dummy texture atlas
    const textureColors = [
      '#000000', // 0: Placeholder/Air
      '#759F5A', // 1: Grass Top
      '#A78869', // 2: Grass Side
      '#7A5B46', // 3: Dirt
      '#95A5A6', // 4: Stone
      '#8A6F4E', // 5: Wood
      '#2ECC71', // 6: Leaves
      '#3498DB', // 7: Water (semi-transparent)
      '#F7DC6F', // 8: Sand
      '#BBBBBB', // 9: Glass (simple gray)
      '#C0392B', // 10: Brick (using this for brick and gold placeholder)
    ];

    textureColors.forEach((color, index) => {
      ctx.fillStyle = color;
      ctx.fillRect(index * TEXTURE_SIZE, 0, TEXTURE_SIZE, TEXTURE_SIZE);

      // Add simple highlights/shadows for better definition
      if (index === 1) { // Grass Top
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(index * TEXTURE_SIZE, 0, TEXTURE_SIZE, 1);
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(index * TEXTURE_SIZE, TEXTURE_SIZE - 1, TEXTURE_SIZE, 1);
      }
    });

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.NearestFilter;
    texture.magFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    // --- Three.js Setup (from previous file) ---

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x7ec0ee); // Sky blue background
    document.body.appendChild(renderer.domElement);
    renderer.domElement.style.position = 'fixed';
    renderer.domElement.style.top = '0';
    renderer.domElement.style.left = '0';
    renderer.domElement.style.zIndex = '1';
    
    // Hide canvas initially
    renderer.domElement.style.display = 'none';

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x7ec0ee, RENDER_DISTANCE * CHUNK_SIZE * 0.5, RENDER_DISTANCE * CHUNK_SIZE * 1.5);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.rotation.order = 'YXZ';

    // Lighting (High ambient light for MeshBasicMaterial)
    const ambient = new THREE.AmbientLight(0xffffff, 2.0); 
    scene.add(ambient);
    
    const sun = new THREE.DirectionalLight(0xfffff4, 1.2);
    scene.add(sun); 

    const world = new World();
    scene.add(world.scene);
    scene.add(createPlayerModel());

    // --- UI Element References ---
    const hud = document.getElementById('hud');
    const hint = document.getElementById('hint');
    const crosshair = document.getElementById('crosshair');
    const controlsUI = document.getElementById('controls-ui');
    const leaveWorldButton = document.getElementById('leave-world-button');
    const saveButton = document.getElementById('floating-save-button');
    const screenshotButton = document.getElementById('download-screenshot-button');
    const startScreen = document.getElementById('start-screen');
    const confirmLeave = document.getElementById('confirm-leave');
    const tutorialBox = document.getElementById('tutorial-box');
    const inventoryPanel = document.getElementById('inventory-panel');
    const btnInventory = document.getElementById('btn-inventory');
    const btnJump = document.getElementById('btn-jump');
    const btnBreak = document.getElementById('btn-break');
    const btnPlace = document.getElementById('btn-place');
    const btnToggleView = document.getElementById('btn-toggle-view');


    // --- Helper for block interaction (Raycasting) ---

    function getTargetedBlock() {
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      raycaster.far = thirdPerson ? 12 : 10; // Allow further reach in 3rd person for building

      const intersects = raycaster.intersectObjects(world.scene.children);

      if (intersects.length > 0) {
        const intersect = intersects[0];
        // Move point slightly back along normal to ensure it's inside the block we hit
        const point = intersect.point.clone().sub(intersect.face.normal.clone().multiplyScalar(0.01));
        const blockPos = new Vector3(
          Math.floor(point.x),
          Math.floor(point.y),
          Math.floor(point.z)
        );
        const normal = intersect.face.normal;

        // Neighbor is the block next to the one hit (where we want to place)
        const neighborPos = new Vector3(
          Math.floor(point.x + normal.x),
          Math.floor(point.y + normal.y),
          Math.floor(point.z + normal.z)
        );

        return {
          break: blockPos,
          place: neighborPos,
          distance: intersect.distance
        };
      }
      return null;
    }

    // --- Collision Functions (from previous file) ---

    function isSolid(x, y, z) {
      const blockId = world.get(Math.floor(x), Math.floor(y), Math.floor(z));
      return BLOCKS[blockId] && BLOCKS[blockId].solid;
    }

    function wouldOverlapPlayer(tx, ty, tz, pPos) {
      // Check if the block at (tx, ty, tz) overlaps the player's collision box
      return tx < pPos.x + player.width / 2 &&
        tx + 1 > pPos.x - player.width / 2 &&
        ty < pPos.y + player.height &&
        ty + 1 > pPos.y &&
        tz < pPos.z + player.width / 2 &&
        tz + 1 > pPos.z - player.width / 2;
    }

    function checkCollision(pos, vel, axis) {
      const step = 0.001; 

      // Define the min/max of the player's bounding box
      const minX = pos.x - player.width / 2;
      const maxX = pos.x + player.width / 2;
      const minY = pos.y;
      const maxY = pos.y + player.height;
      const minZ = pos.z - player.width / 2;
      const maxZ = pos.z + player.width / 2;

      // Determine range of block coordinates to check (including prediction based on velocity)
      const blockXStart = Math.floor(minX + Math.min(0, vel.x));
      const blockXEnd = Math.ceil(maxX + Math.max(0, vel.x));
      const blockYStart = Math.floor(minY + Math.min(0, vel.y));
      const blockYEnd = Math.ceil(maxY + Math.max(0, vel.y));
      const blockZStart = Math.floor(minZ + Math.min(0, vel.z));
      const blockZEnd = Math.ceil(maxZ + Math.max(0, vel.z));

      let maxMovement = vel[axis];

      // Axis-specific iteration ranges setup
      let iStart, iEnd, jStart, jEnd, kStart, kEnd;

      if (axis === 'x') {
        iStart = blockYStart; iEnd = blockYEnd; 
        jStart = blockZStart; jEnd = blockZEnd;
        kStart = blockXStart; kEnd = blockXEnd;
      } else if (axis === 'y') {
        iStart = blockXStart; iEnd = blockXEnd;
        jStart = blockZStart; jEnd = blockZEnd;
        kStart = blockYStart; kEnd = blockYEnd;
      } else { // 'z'
        iStart = blockXStart; iEnd = blockXEnd;
        jStart = blockYStart; jEnd = blockYEnd;
        kStart = blockZStart; kEnd = blockZEnd;
      }

      for (let i = iStart; i < iEnd; i++) {
        for (let j = jStart; j < jEnd; j++) {
          for (let k = kStart; k < kEnd; k++) {
            
            const blockX = (axis === 'x') ? k : (axis === 'y' ? i : k);
            const blockY = (axis === 'x') ? i : (axis === 'y' ? k : j);
            const blockZ = (axis === 'x') ? j : (axis === 'y' ? j : k);

            if (isSolid(blockX, blockY, blockZ)) {
              
              let playerMin, playerMax;
              let blockMin, blockMax;
              
              // Calculate player's boundary on the current axis
              if (axis === 'x' || axis === 'z') {
                playerMin = pos[axis] - player.width / 2;
                playerMax = pos[axis] + player.width / 2;
                blockMin = (axis === 'x') ? blockX : blockZ;
                blockMax = blockMin + 1;
              } else { // 'y'
                playerMin = pos[axis];
                playerMax = pos[axis] + player.height;
                blockMin = blockY;
                blockMax = blockMin + 1;
              }

              // Adjust collision point based on movement direction
              if (vel[axis] > 0) { // Moving positive
                let collisionPoint = blockMin - playerMax;
                if (collisionPoint >= 0 && collisionPoint < vel[axis]) {
                  maxMovement = Math.min(maxMovement, collisionPoint - step);
                }
              } else if (vel[axis] < 0) { // Moving negative
                let collisionPoint = blockMax - playerMin;
                if (collisionPoint <= 0 && collisionPoint > vel[axis]) {
                  maxMovement = Math.max(maxMovement, collisionPoint + step);
                }
              }
            }
          }
        }
      }
      return maxMovement;
    }


    // --- UI/Hotbar/Inventory Functions ---

    function rebuildInventoryUI() {
      const grid = document.getElementById('inventory-grid');
      grid.innerHTML = '';
      
      Object.keys(inventory).map(Number)
        .filter(id => id !== BLOCK_AIR)
        .sort((a, b) => a - b)
        .forEach(id => {
          const slot = document.createElement('div');
          slot.className = 'inventory-slot';
          slot.dataset.blockId = id;
          slot.onclick = () => {
            selectedBlockId = id;
            rebuildHotbarUI();
            toggleInventory(); // Close inventory after selecting
          };

          const block = BLOCKS[id];
          slot.innerHTML = `
            <div class="icon" style="background-color: #${block.color.toString(16).padStart(6,'0')}">${block.preview || ''}</div>
            <div class="count">${inventory[id] || 0}</div>
            <div class="name">${block.name}</div>
          `;
          grid.appendChild(slot);
        });
    }

    function toggleInventory() {
      const isVisible = inventoryPanel.style.display !== 'none';
      if (isVisible) {
        inventoryPanel.style.display = 'none';
        lockCursor();
      } else {
        inventoryPanel.style.display = 'block';
        document.exitPointerLock();
        rebuildInventoryUI();
      }
      // Hide crosshair when inventory is open
      crosshair.style.display = isVisible && inputState.cursorLocked && !thirdPerson ? 'block' : 'none';
    }

    function rebuildHotbarUI() {
      const hotbar = document.getElementById('hotbar');
      hotbar.innerHTML = '';
      const blockIds = Object.keys(inventory).map(Number).filter(id => id !== BLOCK_AIR && inventory[id] > 0).slice(0, 8); // Limit to 8 slots

      blockIds.forEach((id, index) => {
        const slot = document.createElement('div');
        slot.className = `hotbar-slot ${id === selectedBlockId ? 'selected' : ''}`;
        slot.dataset.blockId = id;
        slot.dataset.index = index;

        const block = BLOCKS[id];
        const colorHex = block.color.toString(16).padStart(6, '0');
        slot.innerHTML = `
          <div class="icon" style="background-color: #${colorHex}">${block.preview || ''}</div>
          <div class="count">${inventory[id] || 0}</div>
          <div class="name" style="font-size:10px;">${index + 1}</div>
        `;

        slot.onclick = () => {
          selectedBlockId = id;
          rebuildHotbarUI();
        };

        hotbar.appendChild(slot);
      });
    }

    // --- Input Handlers (Standard setup merged with new mobile buttons) ---

    function lockCursor() {
      if (!inputState.cursorLocked && !inventoryPanel.style.display !== 'none') {
        document.body.requestPointerLock();
      }
    }

    document.addEventListener('pointerlockchange', () => {
      inputState.cursorLocked = document.pointerLockElement !== null;
      if (inputState.cursorLocked) {
        hint.style.display = 'none';
        document.body.style.cursor = 'none';
        crosshair.style.display = thirdPerson ? 'none' : 'block';
      } else if (gameStarted && inventoryPanel.style.display === 'none') {
        // Show hint if unlocked and game is running, and inventory is closed
        hint.style.display = 'block';
        document.body.style.cursor = 'default';
        crosshair.style.display = 'none';
        inputState.forward = inputState.back = inputState.left = inputState.right = inputState.jump = false;
      }
    });

    // Desktop Mouse Events
    renderer.domElement.addEventListener('mousedown', (event) => {
      if (inputState.cursorLocked) {
        if (event.button === 0) inputState.break = true; // Left click
        if (event.button === 2) inputState.place = true; // Right click
      } else {
        lockCursor();
      }
    });
    renderer.domElement.addEventListener('mouseup', (event) => {
      if (event.button === 0) inputState.break = false;
      if (event.button === 2) inputState.place = false;
    });
    renderer.domElement.addEventListener('contextmenu', (event) => event.preventDefault());

    document.addEventListener('mousemove', (event) => {
      if (inputState.cursorLocked) {
        const sensitivity = 0.002;
        camera.rotation.y -= event.movementX * sensitivity;
        camera.rotation.x -= event.movementY * sensitivity;
        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
      }
    });

    document.addEventListener('keydown', (event) => {
      if (inventoryPanel.style.display !== 'none') {
        if (event.code === 'KeyI' || event.code === 'Escape') toggleInventory();
        return;
      }

      switch (event.code) {
        case 'KeyW': inputState.forward = true; break;
        case 'KeyS': inputState.back = true; break;
        case 'KeyA': inputState.left = true; break;
        case 'KeyD': inputState.right = true; break;
        case 'Space': inputState.jump = true; break;
        case 'KeyE': inputState.place = true; break; // E for place
        case 'KeyI': toggleInventory(); break;
        case 'KeyV': thirdPerson = !thirdPerson; break; // V for toggle view

        // Hotbar selection
        case 'Digit1': selectedBlockId = BLOCKS[BLOCK_GRASS] ? BLOCK_GRASS : 1; rebuildHotbarUI(); break;
        case 'Digit2': selectedBlockId = BLOCKS[BLOCK_DIRT] ? BLOCK_DIRT : 2; rebuildHotbarUI(); break;
        case 'Digit3': selectedBlockId = BLOCKS[BLOCK_STONE] ? BLOCK_STONE : 3; rebuildHotbarUI(); break;
        case 'Digit4': selectedBlockId = BLOCKS[BLOCK_WOOD] ? BLOCK_WOOD : 4; rebuildHotbarUI(); break;
        case 'Digit5': selectedBlockId = BLOCKS[BLOCK_LEAVES] ? BLOCK_LEAVES : 5; rebuildHotbarUI(); break;
        case 'Digit6': selectedBlockId = BLOCKS[BLOCK_SAND] ? BLOCK_SAND : 7; rebuildHotbarUI(); break;
        case 'Digit7': selectedBlockId = BLOCKS[BLOCK_GLASS] ? BLOCK_GLASS : 8; rebuildHotbarUI(); break;
        case 'Digit8': selectedBlockId = BLOCKS[BLOCK_BRICK] ? BLOCK_BRICK : 9; rebuildHotbarUI(); break;
      }
    });

    document.addEventListener('keyup', (event) => {
      switch (event.code) {
        case 'KeyW': inputState.forward = false; break;
        case 'KeyS': inputState.back = false; break;
        case 'KeyA': inputState.left = false; break;
        case 'KeyD': inputState.right = false; break;
        case 'Space': inputState.jump = false; break;
        case 'KeyE': inputState.place = false; break;
      }
    });

    // --- Mobile/Touch Handlers ---

    const managerLeft = nipplejs.create({
      zone: document.getElementById('joy-left'),
      mode: 'static',
      position: { left: '50%', top: '50%' },
      color: 'white'
    });
    managerLeft.on('move', (evt, data) => {
      const angle = data.angle.radian;
      const force = data.force;
      const threshold = 0.3;

      inputState.forward = force > threshold && angle > -Math.PI / 4 && angle < Math.PI / 4;
      inputState.back = force > threshold && (angle < -3 * Math.PI / 4 || angle > 3 * Math.PI / 4);
      inputState.right = force > threshold && angle > Math.PI / 4 && angle < 3 * Math.PI / 4;
      inputState.left = force > threshold && angle < -Math.PI / 4 && angle > -3 * Math.PI / 4;
    }).on('end', () => {
      inputState.forward = inputState.back = inputState.left = inputState.right = false;
    });

    const lookArea = document.getElementById('look-area');
    lookArea.addEventListener('touchmove', (event) => {
      if (event.touches.length === 1) {
        const touch = event.touches[0];
        if (lookArea.lastX !== undefined) {
          const movementX = touch.clientX - lookArea.lastX;
          const movementY = touch.clientY - lookArea.lastY;
          const sensitivity = 0.005;

          camera.rotation.y -= movementX * sensitivity;
          camera.rotation.x -= movementY * sensitivity;
          camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }
        lookArea.lastX = touch.clientX;
        lookArea.lastY = touch.clientY;
        event.preventDefault();
      }
    });
    lookArea.addEventListener('touchend', () => {
      lookArea.lastX = undefined;
      lookArea.lastY = undefined;
    });

    // Mobile Button Handlers
    btnJump.addEventListener('pointerdown', () => { if (player.onGround) inputState.jump = true; });
    btnBreak.addEventListener('pointerdown', () => inputState.break = true);
    btnBreak.addEventListener('pointerup', () => inputState.break = false);
    btnPlace.addEventListener('pointerdown', () => inputState.place = true);
    btnPlace.addEventListener('pointerup', () => inputState.place = false);
    btnInventory.addEventListener('click', toggleInventory);
    btnToggleView.addEventListener('click', () => { thirdPerson = !thirdPerson; });


    // --- Game Loop ---

    function animate() {
      if (!gameStarted) {
        requestAnimationFrame(animate);
        return;
      }
      
      const delta = 1000 / 60; 
      placeTimer = Math.max(0, placeTimer - delta);

      // --- Movement Input Handling ---
      let moveX = 0, moveZ = 0;
      if (inputState.forward) moveZ -= 1;
      if (inputState.back) moveZ += 1;
      if (inputState.left) moveX -= 1;
      if (inputState.right) moveX += 1;

      const movementVector = new Vector3(moveX, 0, moveZ).normalize();
      const angle = camera.rotation.y;
      movementVector.applyAxisAngle(new Vector3(0, 1, 0), angle);

      if (moveX !== 0 || moveZ !== 0) {
        player.vel.x += movementVector.x * MAX_SPEED;
        player.vel.z += movementVector.z * MAX_SPEED;
      }

      // Clamp horizontal velocity
      const totalSpeed = Math.sqrt(player.vel.x * player.vel.x + player.vel.z * player.vel.z);
      if (totalSpeed > MAX_SPEED) {
        player.vel.x *= MAX_SPEED / totalSpeed;
        player.vel.z *= MAX_SPEED / totalSpeed;
      }

      // --- Jump Input Handling ---
      if (inputState.jump && player.onGround) {
        player.vel.y = JUMP_VELOCITY;
        player.onGround = false;
        inputState.jump = false; 
      }

      // --- Apply Physics ---

      // Apply gravity
      player.vel.y -= GRAVITY;

      // Apply drag/friction
      if (player.onGround) {
        player.vel.x *= FRICTION;
        player.vel.z *= FRICTION;
      } else {
        player.vel.x *= AIR_DRAG;
        player.vel.z *= AIR_DRAG;
      }

      // Check for zero velocity to prevent endless floating point drift
      if (Math.abs(player.vel.x) < 0.0001) player.vel.x = 0;
      if (Math.abs(player.vel.z) < 0.0001) player.vel.z = 0;

      // --- Collision Detection and Response ---

      let newPos = player.pos.clone();

      // 1. X-axis collision
      player.vel.x = checkCollision(player.pos, player.vel, 'x');
      newPos.x = player.pos.x + player.vel.x;
      player.pos.copy(newPos); // Update position

      // 2. Z-axis collision
      player.vel.z = checkCollision(player.pos, player.vel, 'z');
      newPos.z = player.pos.z + player.vel.z;
      player.pos.copy(newPos); // Update position

      // 3. Y-axis collision
      const oldYVel = player.vel.y;
      player.vel.y = checkCollision(player.pos, player.vel, 'y');
      newPos.y = player.pos.y + player.vel.y;
      player.pos.copy(newPos); // Update position

      // Check if player landed
      if (oldYVel < 0 && player.vel.y === 0) {
        player.onGround = true;
      } else {
        player.onGround = false;
      }

      // Keep player above minimum floor (teleport safety)
      if (player.pos.y < -50) {
        player.pos.set(0, CHUNK_SIZE * WORLD_HEIGHT * 0.7, 0);
        player.vel.set(0, 0, 0);
        player.onGround = true;
      }

      // --- Camera Update (First/Third Person) ---
      
      const eyeOffset = player.height * 0.9;

      if (thirdPerson) {
          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);
          const backVector = direction.negate();
          
          let targetPos = player.pos.clone().add(new Vector3(0, eyeOffset, 0));
          let cameraPos = targetPos.clone().add(backVector.multiplyScalar(THIRD_PERSON_DISTANCE));
          
          // Raycast to check for obstructions
          const raycaster = new THREE.Raycaster(targetPos, backVector.normalize());
          const intersects = raycaster.intersectObjects(world.scene.children);
          
          if (intersects.length > 0 && intersects[0].distance < THIRD_PERSON_DISTANCE) {
              cameraPos = targetPos.clone().add(backVector.multiplyScalar(intersects[0].distance - 0.5));
          }

          camera.position.lerp(cameraPos, 0.1);
          camera.lookAt(targetPos);
          playerModel.visible = true;
          crosshair.style.display = 'none';
      } else {
          camera.position.set(player.pos.x, player.pos.y + eyeOffset, player.pos.z);
          playerModel.visible = false;
          crosshair.style.display = inputState.cursorLocked ? 'block' : 'none';
      }
      
      // Update player model position and rotation (only if visible)
      if (playerModel.visible) {
          playerModel.position.set(player.pos.x, player.pos.y, player.pos.z);
          playerModel.rotation.y = camera.rotation.y;
      }

      // This function loads/unloads chunks based on player movement
      world.updateMeshes(); 

      // --- Block Breaking/Placing ---
      const target = getTargetedBlock();

      // Block Breaking
      if (inputState.break && placeTimer === 0 && target) {
        const { x: tx, y: ty, z: tz } = target.break;
        const blockId = world.get(tx, ty, tz);
        if (blockId !== BLOCK_AIR && blockId !== BLOCK_WATER) {
          world.set(tx, ty, tz, BLOCK_AIR);
          inventory[blockId] = (inventory[blockId] || 0) + 1;
          world.updateMeshes();
          rebuildHotbarUI();
          placeTimer = COOLDOWN_MS;
        }
        inputState.break = false;
      }

      // Block Placing
      if (inputState.place && placeTimer === 0 && target && allowPlacing) {
        const { x: tx, y: ty, z: tz } = target.place;
        if (world.inBounds(tx, ty, tz) && world.get(tx, ty, tz) === BLOCK_AIR && !wouldOverlapPlayer(tx, ty, tz, player.pos)) {
          if ((inventory[selectedBlockId] || 0) > 0) {
            world.set(tx, ty, tz, selectedBlockId);
            inventory[selectedBlockId] = Math.max(0, (inventory[selectedBlockId] || 0) - 1);
            world.updateMeshes();
            rebuildHotbarUI();
            placeTimer = COOLDOWN_MS;
          }
        }
        inputState.place = false;
      }

      // Sun rotation
      const t = performance.now() * 0.00012;
      sun.position.set(50 * Math.sin(t), 50 * Math.cos(t), 20 * Math.cos(t * 0.7));

      hud.innerHTML = `Pos: ${player.pos.x.toFixed(2)}, ${player.pos.y.toFixed(2)}, ${player.pos.z.toFixed(2)}<br>` +
                      `Chunk: ${getChunkPos(player.pos.x, 0, player.pos.z).cx}, ${getChunkPos(player.pos.x, 0, player.pos.z).cz}<br>` +
                      `Selected: ${BLOCKS[selectedBlockId].name} (${inventory[selectedBlockId] || 0})<br>` +
                      `View: ${thirdPerson ? '3rd Person (V)' : '1st Person'}`;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // --- Initialization & UI Flow ---

    function startWorld() {
        startScreen.style.display = 'none';
        renderer.domElement.style.display = 'block';
        hud.style.display = 'block';
        leaveWorldButton.style.display = 'block';
        saveButton.style.display = 'block';
        screenshotButton.style.display = 'block';
        controlsUI.style.display = 'flex'; // Show mobile controls
        hint.style.display = 'block';

        // Reset player position for a new game
        player.pos.set(0, CHUNK_SIZE * WORLD_HEIGHT * 0.7, 0);
        player.vel.set(0, 0, 0);

        // Initial chunk generation around player starting position
        const { cx, cz } = getChunkPos(player.pos.x, player.pos.y, player.pos.z);
        for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
          for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
            world.generateTerrain(cx + x, cz + z);
          }
        }
        world.updateMeshes();
        rebuildHotbarUI();

        if (!gameStarted) {
          gameStarted = true;
          requestAnimationFrame(animate); // Start the main loop
        }
    }
function exitWorld() {
        gameStarted = false;
        document.exitPointerLock();
        startScreen.style.display = 'flex';
        renderer.domElement.style.display = 'none';
        hud.style.display = 'none';
        leaveWorldButton.style.display = 'none';
        saveButton.style.display = 'none';
        screenshotButton.style.display = 'none';
        controlsUI.style.display = 'none';
        hint.style.display = 'none';
        crosshair.style.display = 'none';
        confirmLeave.style.display = 'none';
        inventoryPanel.style.display = 'none';
        
        // Clear chunks and scene to release memory
        for (const key in world.chunkMeshes) {
            world.scene.remove(world.chunkMeshes[key]);
        }
        world.chunks = {};
        world.chunkMeshes = {};
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize, false);
    
    // UI Event Listeners (from user's new code structure)
    const select = document.getElementById('world-select');
    const loadBtn = document.getElementById('load-world-button');
    const newBtn = document.getElementById('new-world-button');

    ['Demo World 1', 'Demo World 2'].forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      select.appendChild(opt);
    });

    loadBtn.addEventListener('click', startWorld);

    newBtn.addEventListener('click', () => {
      const name = prompt('Enter new world name:');
      if (!name) return;
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      select.appendChild(opt);
      select.value = name;
      startWorld();
    });
    
    // Tutorial/Leave Handlers
    document.getElementById('toggle-tutorial-button').addEventListener('click', () => {
      tutorialBox.style.display = tutorialBox.style.display === 'block' ? 'none' : 'block';
    });
    
    leaveWorldButton.addEventListener('click', () => {
        document.exitPointerLock();
        confirmLeave.style.display = 'flex';
    });
    
    document.getElementById('cancel-leave-button').addEventListener('click', () => {
        confirmLeave.style.display = 'none';
        lockCursor();
    });
    
    document.getElementById('confirm-leave-button').addEventListener('click', exitWorld);
    
    // Placeholder screenshot button logic
    document.getElementById('download-screenshot-button').addEventListener('click', () => {
        const dataURL = renderer.domElement.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataURL;
        a.download = 'shadow-craft-screenshot.png';
        a.click();
    });

    // Initial State Setup
    onWindowResize();
    
  </script>
</body>
</html>
