<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Shadow-craft ‚Äî optimized terrain & collision</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    html,body { height:100%; margin:0; background:#111; overflow:hidden; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; -webkit-user-select:none; user-select:none; touch-action:none; }
    #hud { position:fixed; left:12px; top:12px; z-index:60; background:rgba(0,0,0,0.45); color:#fff; padding:10px 12px; border-radius:8px; font-family: monospace; font-size:13px; max-width:46%; }
    #hint { position:fixed; left:50%; transform:translateX(-50%); bottom:14px; z-index:50; color:#fff; background:rgba(0,0,0,0.35); padding:8px 12px; border-radius:8px; font-size:13px; }
    #controls-ui { position:fixed; left:0; right:0; bottom:0; display:flex; justify-content:space-between; padding:12px; z-index:45; pointer-events:none; }
    #joy-left { width:140px; height:140px; margin-left:12px; pointer-events:auto; touch-action:none; position:relative; }
    .joy-bg { width:100%; height:100%; background:rgba(255,255,255,0.04); border-radius:50%; border:1px solid rgba(255,255,255,0.08); display:flex; align-items:center; justify-content:center; }
    .joy-knob { width:48px; height:48px; background:rgba(255,255,255,0.14); border-radius:50%; transform:translate(-50%,-50%); position:absolute; left:50%; top:50%; pointer-events:none; display:flex; align-items:center; justify-content:center; color:#fff; font-size:14px; }
    #right-controls { margin-right:12px; display:flex; flex-direction:column; gap:10px; pointer-events:none; align-items:flex-end; }
    #start-screen {
      position: fixed; 
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(-45deg, #0f0f0f, #1a1a1a, #222, #0f0f0f);
      background-size: 400% 400%;
      animation: gradientShift 12s ease infinite;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
    }
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    #look-area {
      position: fixed;
      top: 0;
      right: 0;
      width: 50%;
      height: calc(100% - 120px);
      background: rgba(255,255,255,0.02);
      touch-action: none;
      pointer-events: auto;
      z-index: 40;
    }
    #button-stack {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      pointer-events: auto;
      z-index: 50;
    }
    .action-row {
      display: flex;
      gap: 10px;
      justify-content: center;
      pointer-events: auto;
    }
    .btn { width:56px; height:56px; background:rgba(255,255,255,0.06); border-radius:12px; border:1px solid rgba(255,255,255,0.12); color:#fff; font-size:20px; display:flex; align-items:center; justify-content:center; user-select:none; touch-action:manipulation; pointer-events: auto;}
    #hotbar { position:fixed; left:50%; transform:translateX(-50%); bottom:84px; z-index:55; display:flex; gap:8px; pointer-events:none; }
    .hotbar-slot { pointer-events:auto; width:64px; height:64px; background:rgba(0,0,0,0.6); border-radius:8px; border:2px solid rgba(255,255,255,0.08); display:flex; flex-direction:column; align-items:center; justify-content:center; color:#fff; font-size:12px; cursor:pointer; box-sizing:border-box; }
    .hotbar-slot .icon { width:36px; height:36px; border-radius:6px; margin-bottom:6px; background-size:cover; background-position:center; box-shadow: inset 0 -6px 12px rgba(0,0,0,0.25); }
    .hotbar-slot .count { font-size:11px; opacity:0.9; }
    .hotbar-slot.selected { border-color: #ffd36b; box-shadow: 0 0 12px rgba(255,211,107,0.18); transform:translateY(-4px); }
    #progress { position:fixed; left:50%; transform:translateX(-50%); bottom:156px; z-index:68; width:260px; height:14px; background:rgba(255,255,255,0.06); border-radius:8px; overflow:hidden; display:none }
    #progress > div { height:100%; width:0%; background:linear-gradient(90deg,#ffd36b,#ff8a3d); border-radius:8px }
    @media (pointer: fine) { #controls-ui { display:none; } }
    @media (max-width: 420px) {
  #crosshair {
    font-size: 20px;
  }
  #look-area {
    width: 220px;
    height: 360px;
  }
  #joy-left {
    width: 100px;
    height: 100px;
  }
  .btn {
    width: 44px;
    height: 44px;
    font-size: 18px;
  }
  .hotbar-slot {
    width: 48px;
    height: 48px;
    font-size: 10px;
  }
  .hotbar-slot .icon {
    width: 28px;
    height: 28px;
    margin-bottom: 4px;
  }
  .hotbar-slot .count {
    font-size: 9px;
  }
  #inventory-grid {
    grid-template-columns: repeat(9, 48px);
    gap: 6px;
  }
  .inventory-slot {
    width: 48px;
    height: 48px;
    font-size: 10px;
  }
  .inventory-slot .icon {
    width: 28px;
    height: 28px;
    margin-bottom: 2px;
  }
    }
    
    canvas { display:block; }
    #inventory-panel {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      padding: 20px;
      border-radius: 12px;
      z-index: 70;
      display: none;
    }
    #inventory-grid {
      display: grid;
      grid-template-columns: repeat(9, 64px);
      gap: 8px;
    }
    .inventory-slot {
      width: 64px;
      height: 64px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 12px;
    }
    .inventory-slot .icon {
      width: 36px;
      height: 36px;
      margin-bottom: 4px;
      background-size: cover;
      background-position: center;
    }
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 28px;
      color: rgba(255,255,255,0.85);
      z-index: 65;
      pointer-events: none;
      user-select: none;
    }
    #leave-world-button {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 100;
      padding: 10px 18px;
      font-size: 16px;
      background: linear-gradient(90deg, #ff8a3d, #ffd36b);
      color: #000;
      border: none;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    #leave-world-button:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    #world-select {
      padding: 10px 14px;
      font-size: 16px;
      border-radius: 8px;
      border: none;
      background: rgba(255,255,255,0.1);
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      margin-bottom: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      outline: none;
    }
    #world-select option {
      background: #222;
      color: #fff;
    }
    #load-world-button,
    #new-world-button {
      padding: 10px 18px;
      font-size: 16px;
      background: #ffd36b;
      color: #000;
      border: none;
      border-radius: 10px;
      box-shadow: 0 0 12px rgba(255,211,107,0.4);
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    #load-world-button:hover,
    #new-world-button:hover {
      transform: scale(1.08);
      box-shadow: 0 0 20px rgba(255,211,107,0.6);
    }
    #confirm-box {
      background: #222;
      padding: 20px 30px;
      border-radius: 12px;
      text-align: center;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      box-shadow: 0 44px 12px rgba(0,0,0,0.4);
    }
    #confirm-box p {
      font-size: 18px;
      margin-bottom: 20px;
    }
    #confirm-box button {
      padding: 10px 18px;
      font-size: 16px;
      margin: 0 10px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.2s ease;
    }
    #confirm-leave-button {
      background: linear-gradient(90deg, #ffd36b, #ff8a3d);
      color: #000;
    }
    #cancel-leave-button {
      background: #555;
      color: #fff;
    }
    #confirm-box button:hover {
      transform: scale(1.05);
    }
    #game-title {
      font-size: 48px;
      color: #ffd36b;
      text-shadow: 0 0 12px rgba(255,211,107,0.4);
      animation: floatTitle 4s ease-in-out infinite;
    }
    @keyframes floatTitle {
      0% { transform: translateY(0); }
      50% { transform: translateY(-6px); }
      100% { transform: translateY(0); }
    }
    #particle-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      z-index: 99;
      background-image: radial-gradient(circle, rgba(255,255,255,0.05) 1px, transparent 1px);
      background-size: 20px 20px;
      animation: particleDrift 30s linear infinite;
    }
    @keyframes particleDrift {
      0% { background-position: 0 0; }
      100% { background-position: 100px 100px; }
    }
    #tutorial-box {
      animation: fadeIn 2s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    #toggle-tutorial-button {
      padding: 10px 18px;
      font-size: 16px;
      background: linear-gradient(90deg, #6bcaff, #3d9eff);
      color: #000;
      border: none;
      border-radius: 10px;
      box-shadow: 0 0 12px rgba(107,202,255,0.4);
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    #toggle-tutorial-button:hover {
      transform: scale(1.08);
      box-shadow: 0 0 20px rgba(107,202,255,0.6);
    }
    #confirm-leave {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    #tutorial-box {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.85);
      padding: 16px 20px;
      border-radius: 12px;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      font-size: 14px;
      max-width: 320px;
      z-index: 150;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      animation: fadeIn 0.5s ease-out;
    }
    .floating-btn {
      position: fixed;
      top: 12px;
      z-index: 80;
      padding: 8px 14px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .floating-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    #floating-save-button {
      left: 12px;
      background: linear-gradient(90deg, #aaaaaa, #666666);
      color: #fff;
    }
    #download-screenshot-button {
      left: 120px;
      background: linear-gradient(90deg, #b2f8a8, #5ed64c);
      color: #000;
    }
  </style>
</head>
<body>
  <div id="particle-overlay"></div>
  <div id="start-screen">
    <h1 id="game-title">Shadow-craft</h1>
    <select id="world-select"></select>
    <div style="display: flex; gap: 12px; margin-top: 12px;">
      <button id="load-world-button">‚ñ∂Ô∏è Load World</button>
      <button id="new-world-button">üåç Create New World</button>
      <button id="toggle-tutorial-button">üìò Tutorial</button>
    </div>
  </div>
  <button id="floating-save-button" class="floating-btn" disabled>üíæ Save (Disabled)</button>
  <button id="download-screenshot-button" class="floating-btn">üñºÔ∏è Screenshot</button>
  
  <div id="tutorial-box" style="display:none;">
    <h2>üïπÔ∏è How to Play</h2>
    <div class="tutorial-section">
      <h3>üíª PC Controls</h3>
      <ul>
        <li><b>WASD</b> ‚Äî Move</li>
        <li><b>Space</b> ‚Äî Jump</li>
        <li><b>Q</b> ‚Äî Break block</li>
        <li><b>E</b> ‚Äî Place block</li>
        <li><b>P</b> ‚Äî Toggle placing</li>
        <li><b>I</b> ‚Äî Open inventory</li>
        <li><b>1‚Äì9</b> ‚Äî Select block</li>
        <li><b>Click</b> ‚Äî Lock pointer</li>
      </ul>
    </div>
    <div class="tutorial-section">
      <h3>üì± Mobile Controls</h3>
      <ul>
        <li><b>Left joystick</b> ‚Äî Move</li>
        <li><b>Right drag</b> ‚Äî Look around</li>
        <li><b>‚è´</b> ‚Äî Jump</li>
        <li><b>‚õè</b> ‚Äî Break block</li>
        <li><b>üß±</b> ‚Äî Place block</li>
        <li><b>üéí</b> ‚Äî Open inventory</li>
        <li><b>üëÅÔ∏è</b> ‚Äî Toggle view</li>
      </ul>
    </div>
  </div>
  
  <button id="leave-world-button">‚èπ Leave World</button>
  <div id="confirm-leave" style="display:none;">
    <div id="confirm-box">
      <p>Are you sure you want to leave this world?</p>
      <div class="confirm-buttons">
        <button id="confirm-leave-button">‚úÖ Yes, Leave</button>
        <button id="cancel-leave-button">‚ùå Cancel</button>
      </div>
    </div>
  </div>
  
  <div id="hud">Loading...</div>
  <div id="hint">Click to lock pointer (desktop). WASD to move, Space to jump, Q break. Placing remains disabled by default. Mobile: left joystick move, right drag look.</div>
  <div id="crosshair">+</div>
  
  <div id="controls-ui" aria-hidden="true">
    <div id="joy-left" aria-hidden="true"><div class="joy-bg"></div><div class="joy-knob" id="joy-knob">‚Ä¢</div></div>
    <div id="right-controls" aria-hidden="true">
      <div id="look-area" title="Drag here to look (mobile)"></div>
      <div id="button-stack">
        <div class="btn" id="btn-jump">‚è´</div>
        <div class="btn" id="btn-toggle-view">üëÅÔ∏è</div>
        <div class="action-row">
          <div class="btn" id="btn-break">‚õè</div>
          <div class="btn" id="btn-place">üß±</div>
          <div class="btn" id="btn-inventory">üéí</div>
        </div>
      </div>
    </div>
  </div>
  <div id="hotbar"></div>
  <div id="inventory-panel" style="display:none;">
    <div id="inventory-grid"></div>
  </div>
  <div id="progress"><div></div></div>

  <script type="module">
 import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
function setPixel(ctx, x, y, r, g, b, a = 255) {
  const img = ctx.getImageData(0, 0, 16, 16);
  const i = (y * 16 + x) * 4;
  img.data[i] = r;
  img.data[i + 1] = g;
  img.data[i + 2] = b;
  img.data[i + 3] = a;
  ctx.putImageData(img, 0, 0);
}

function getPixels(encoded) {
  const raw = atob(encoded.slice(4));
  const out = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) out[i] = raw.charCodeAt(i);
  return out;
    }
   function makeBlockCanvasFromTexture(def) {
  const canvas = document.createElement('canvas');
     canvas.width = canvas.height = 16;
                  
  const ctx = canvas.getContext('2d');

  if (typeof def === 'function') {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 16, 16);
    def(ctx);
  } else if (typeof def === 'string') {
    const pix = getPixels(def);
    const img = ctx.createImageData(16, 16);
    for (let i = 0; i < pix.length; i++) img.data[i] = pix[i];
    ctx.putImageData(img, 0, 0);
  }

  return canvas;
      }
   const textures = {
  grassTop: function(ctx) {
    for (let x = 0; x < 16; x++) {
      for (let y = 0; y < 16; y++) {
        const d = Math.random() * 0.25 + 0.65;
        const r = 0x54 * d, g = 0xa0 * d, b = 0x48 * d;
        setPixel(ctx, x, y, r, g, b);
      }
    }
  },
  leaves: function(ctx) {
    for (let x = 0; x < 16; x++) {
      for (let y = 0; y < 16; y++) {
        const g = Math.floor(Math.random() * 30 + 100);
        const b = Math.floor(Math.random() * 30);
        const a = Math.random() < 0.35 ? 0 : 255;
        setPixel(ctx, x, y, 0, g, b, a);
      }
    }
  },
  oakPlanks: function(ctx) {
    for (let y = 0; y < 16; y++) {
      const a = (y & 3) === 3 ? 0.7 : 1;
      for (let x = 0; x < 16; x++) {
        const mid = x === 8 && (y & 7) > 3 && a === 1 ? 0.85 : 1;
        const rit = x === 15 && (y & 7) < 3 && a === 1 ? 0.85 : 1;
        const r = (Math.random() * 0.1 + 0.9) * a * mid * rit;
        setPixel(ctx, x, y, 190 * r, 154 * r, 96 * r);
      }
    }
  },
  dirt: "0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530",
  stone: "0g0gf0v74dmg0v74f7c0xf169k0xf17ug0xfcet40xfcge00xfchyw0xfnoxk0zn97g80zn99140znkfzs0znkhko0znkj5k11vh8mw11vsirc5548515111111551595851111155b55155558535155bb555555556556b55bb55b5b85bbb56535bbbbbbbbbcb5b5bbbb6bebbeebebbbbbbbbbeebbebbbbeebb5b1beeeeb555bb555b5a5deebbbbbbb55bbbbeeebb558b555bbabdeebbb51b5551babeebbbb559555555beeb115b15555515552555bb5a5b751051241bb1555551",
  sand: function(ctx) {
    ctx.fillStyle = '#d2b48c';
    ctx.fillRect(0, 0, 16, 16);
    ctx.fillStyle = 'rgba(0,0,0,0.04)';
    for (let i = 0; i < 100; i++) {
      ctx.fillRect(Math.random() * 16, Math.random() * 16, 1, 1);
    }
  },
  cobblestone: "0g0go08ww4xk0flk8hk0hts9o80k209a00ma8ago0ma8c1k0majkl40oi533s0oigbnc0oigd880qqd4ag0qqocu00qqoeew0syl5h40sywe0o0sywflk0sz7o540v6t52w0v6t6ns0v74f7c0xf169k0xf17ug0xfcge00znkhko0deje0h808bbbe000ekme000079ab90f000000ie0400000j0mlmj0e00j03210b000000000800000b0jcc0jm0040e9809000b0jm000000000mm000mm0jg0nmnejem0n09b08800000ejm0m00005ejjjf0jmj0n0m00ejmjeb0emj0m0fn00000000b000b0bj0el0mlj04450b0b608j0jmj08000000000000000008b8802054048088",
     goldOre: "0g0g80sywflr0wb8hdr0zdjj0f13tzldr1x01czj1y6gem71z13ncv1z141z33223211210112333221203333220002121005120011265223332322642322311122110013212312223220762217610131227655432542222100223330001133336523210762122312232021644423332021251001330021122222333301643322110033167655421332642223442122221123332233211122222221322222233",
  bricks: "0g0g811twquw1aq69rs1cyeayg1cyecjc1f6b3lk1f6mc541f6mdq01hej4s80000000000000000052552220525522006775542067755400566455105664550000000000000000032203525422205255530377655420777352025563531055600000000000000000525522205255220077755420777554005664551056645500000000000000000322035254222052555303777554207773520255635310556"
     
};
     
    const select = document.getElementById('world-select');
    const loadBtn = document.getElementById('load-world-button');
    const newBtn = document.getElementById('new-world-button');

    // Stub/initialization for dropdown and world loading/creation
    ['Demo World 1', 'Demo World 2'].forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      select.appendChild(opt);
    });

    let currentWorldName = select.value || 'Demo World 1';

    // Load selected world - now just starts the game
    loadBtn.addEventListener('click', () => {
      currentWorldName = select.value;
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('tutorial-box').style.display = 'none';
      tick(); // Start game loop
    });

    // Create new world - now just prompts for name and starts the game
    newBtn.addEventListener('click', () => {
      const name = prompt('Enter new world name:');
      if (!name) return;
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      select.appendChild(opt);
      select.value = name;
      currentWorldName = name;
      
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('tutorial-box').style.display = 'none';
      tick(); // Start game loop
      
    });
      
    function createPlayerModel() {
      const skinCanvas = makePlayerSkinCanvas();
      const skinTexture = new THREE.CanvasTexture(skinCanvas);
      skinTexture.magFilter = THREE.NearestFilter;

      const mat = new THREE.MeshBasicMaterial({ map: skinTexture });

      const group = new THREE.Group();

      const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), mat);
      head.position.set(0, 1.8, 0); group.add(head);

      const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.6), mat);
      torso.position.set(0, 0.9, 0); group.add(torso);

      const armL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), mat);
      armL.position.set(-0.65, 0.9, 0); group.add(armL);

      const armR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), mat);
      armR.position.set(0.65, 0.9, 0); group.add(armR);

      const legL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.4), mat);
      legL.position.set(-0.25, 0.0, 0); group.add(legL);

      const legR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.4), mat);
      legR.position.set(0.25, 0.0, 0); group.add(legR);

      return group;
    }
    
    // ===== Optimized: flatter terrain, fewer trees, collision fixes, lower pixel ratio =====
    const WORLD_W = 100, WORLD_H = 36, WORLD_D = 100;
    const PLAYER_EYE = 1.6;
    const JOY_DEADZONE = 0.18, MAX_JOY = 48;
    const BLOCK_AIR = 0;
    let thirdPerson = false;
      
    const BLOCKS = {
  1: { name: 'Dirt', color: 0x5a3e2b },
  2: { name: 'Stone', color: 0x6e6e6e },
  // FIX: 'Grass' was looking for 'grass', but the texture key is 'grassTop'.
  3: { name: 'GrassTop', color: 0x2e8b57 }, 
  // FIX: 'Wood' was looking for 'wood', but the texture key is 'oakPlanks'.
  4: { name: 'OakPlanks', color: 0x7b4a2b },
  5: { name: 'Leaves', color: 0x3e803e },
  6: { name: 'Sand', color: 0xd2b48c },
  7: { name: 'Cobblestone', color: 0x555555 },
  // FIX: 'Brick' was looking for 'brick', but the texture key is 'bricks'.
  8: { name: 'Bricks', color: 0x8b0000 },
  // Block 9 'Gold' is still missing a texture key in the 'textures' object.
  9: { name: 'Gold', color: 0xffc300 },
    }
    let inventory = {};
    for (const id in BLOCKS) {
      inventory[id] = 999; // start with full inventory in this no-save version
    }
    
    let selectedBlockId = 1;
    let allowPlacing = true;

    function idx(x,y,z){ return x + WORLD_W*(z + WORLD_D*y); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function inBounds(x,y,z){ return x>=0 && y>=0 && z>=0 && x<WORLD_W && y<WORLD_H && z<WORLD_D; }

    // procedural textures (small canvases)
    
    
    function makePlayerSkinCanvas() {
      const size = 64;
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');

      // Skin base
      ctx.fillStyle = '#f2c18d'; // skin tone
      ctx.fillRect(0, 0, size, size);

      // Hair
      ctx.fillStyle = '#5a3e2b'; // brown
      ctx.fillRect(0, 0, size, 16);

      // Eyes
      ctx.fillStyle = '#000';
      ctx.fillRect(20, 24, 4, 4);
      ctx.fillRect(40, 24, 4, 4);

      // Shirt
      ctx.fillStyle = '#2e8b57'; // green
      ctx.fillRect(0, 32, size, 16);

      // Pants
      ctx.fillStyle = '#555'; // gray
      ctx.fillRect(0, 48, size, 16);

      return c;
    }
    
    const materialCache = {};
   function getMaterialForBlock(id) {
  if (materialCache[id]) return materialCache[id];

  const def = textures[BLOCKS[id].name.toLowerCase()] || textures.dirt;
  const canvas = makeBlockCanvasFromTexture(def);
  const tex = new THREE.CanvasTexture(canvas);
  tex.magFilter = THREE.NearestFilter;
  tex.minFilter = THREE.NearestFilter;
  tex.needsUpdate = true;

  const mat = new THREE.MeshLambertMaterial({ map: tex });
  materialCache[id] = { material: mat, textureCanvas: canvas };
  return materialCache[id];
    }
    
    

    // shared cube geometry to reduce allocations
    const cubeGeom = new THREE.BoxGeometry(1,1,1);

    class VoxelWorld {
      constructor(w,h,d, scene){
        this.w=w; this.h=h; this.d=d;
        this.blocks = new Uint8Array(w*h*d);
        this.group = new THREE.Group();
        this._meshes = {};
        if(scene) scene.add(this.group);
        this.generateTerrain();
        this.updateMeshes();
      }
      generateTerrain(){
        for(let x=0;x<this.w;x++){
          for(let z=0;z<this.d;z++){
            // much flatter: low base + small noise
            const ridge = Math.sin(x*0.08) * Math.cos(z*0.06);
            let h = Math.floor(1 + 3*(0.5 + 0.5*ridge) + Math.floor(Math.random()*1));
            const distEdge = Math.min(x,z,this.w-1-x,this.d-1-z);
            if(distEdge < 3) h = Math.max(1, 1 + Math.floor(Math.random()*1.2));
            for(let y=0;y<h;y++){
              if(distEdge < 3) this.set(x,y,z,6); else if(y < h-1) this.set(x,y,z,2); else this.set(x,y,z,3);
            }
            // fewer trees
            if(h>2 && Math.random() < 0.15 && distEdge >= 5){
              const trunk = 2 + Math.floor(Math.random()*2);
              for(let ty=h; ty<h+trunk && ty<this.h-1; ty++) this.set(x,ty,z,4);
              const ly = Math.min(h+trunk, this.h-2);
              for(let ix=-1; ix<=1; ix++) for(let iz=-1; iz<=1; iz++) for(let iy=0; iy<=1; iy++){
                const lx=x+ix, lz=z+iz, lypos=ly+iy;
                if(this.inBounds(lx,lypos,lz) && this.get(lx,lypos,lz)===BLOCK_AIR) this.set(lx,lypos,lz,5);
              }
            }
          }
        }
      }
      inBounds(x,y,z){ return x>=0 && y>=0 && z>=0 && x<this.w && y<this.h && z<this.d; }
      get(x,y,z){ if(!this.inBounds(x,y,z)) return BLOCK_AIR; return this.blocks[idx(x,y,z)]; }
      set(x,y,z,v){ if(!this.inBounds(x,y,z)) return; this.blocks[idx(x,y,z)] = v; }
      updateMeshes(){
        // clear previous
        while(this.group.children.length){ const c = this.group.children.pop(); if(c.geometry) c.geometry.dispose?.(); if(c.material) c.material.dispose?.(); }
        this._meshes = {};
        const lists = {};
        for(let x=0;x<this.w;x++) for(let y=0;y<this.h;y++) for(let z=0;z<this.d;z++){ const bid = this.get(x,y,z); if(bid && bid!==BLOCK_AIR) (lists[bid]=lists[bid]||[]).push({x,y,z}); }
        const tmp = new THREE.Matrix4();
        Object.keys(lists).forEach(k=>{
          const id = parseInt(k,10);
          const arr = lists[k];
          const matInfo = getMaterialForBlock(id);
          const inst = new THREE.InstancedMesh(cubeGeom, matInfo.material, arr.length);
          inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
          for(let i=0;i<arr.length;i++){ tmp.makeTranslation(arr[i].x+0.5, arr[i].y+0.5, arr[i].z+0.5); inst.setMatrixAt(i,tmp); }
          inst.count = arr.length;
          inst.userData.blockId = id;
          inst.frustumCulled = true;
          this.group.add(inst);
          this._meshes[id] = inst;
        });
      }
    }

    // ---------- Input, hotbar & UI ----------
    const inputState = { fw:0, bk:0, lt:0, rt:0, run:false, jump:false, place:false, break:false };
    const joystick = { active:false, id:null, startX:0, startY:0, dx:0, dy:0 };
    const hud = document.getElementById('hud');
    const hotbarEl = document.getElementById('hotbar');
    const progressBar = document.getElementById('progress');
    const progressFill = progressBar.querySelector('div');

    function rebuildInventoryUI() {
      const grid = document.getElementById('inventory-grid');
      grid.innerHTML = '';
      const keys = Object.keys(BLOCKS).map(x => parseInt(x));
                      
      for (const id of keys) {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        const matInfo = getMaterialForBlock(id);
        const dataURL = matInfo.textureCanvas.toDataURL();
        slot.innerHTML = `<div class="icon" style="background-image:url('${dataURL}')"></div><div>${BLOCKS[id].name}<br>${inventory[id] || 0}</div>`;
        slot.addEventListener('click', () => {
          selectedBlockId = id;
          rebuildHotbarUI();
        });
        grid.appendChild(slot);
      }
    }
    
    function rebuildHotbarUI(){
      hotbarEl.innerHTML = '';
      const keys = Object.keys(BLOCKS).map(x=>parseInt(x));
      for(const id of keys){
        const slot = document.createElement('div');
        slot.className = 'hotbar-slot' + (id===selectedBlockId ? ' selected' : '');
        slot.dataset.bid = id;
        const matInfo = getMaterialForBlock(id);
        const dataURL = matInfo.textureCanvas.toDataURL();
        slot.innerHTML = `<div class="icon" style="background-image:url('${dataURL}')"></div><div class="count">${inventory[id] ?? 0}</div>`;
        slot.title = BLOCKS[id].name;
        slot.addEventListener('click', ()=>{ selectedBlockId = id; rebuildHotbarUI(); });
        slot.addEventListener('touchstart', (e)=>{ e.preventDefault(); selectedBlockId = id; rebuildHotbarUI(); }, {passive:false});
        hotbarEl.appendChild(slot);
      }
      const hint = document.getElementById('hint');
      hint.innerText = allowPlacing ? 'Placing enabled ‚Äî E to place. Press P to toggle. Press Q to break' : 'Placing DISABLED ‚Äî cannot place blocks. Press P to toggle. Press Q to break';
    }

    function tick() {
      requestAnimationFrame(tick);

      // ‚úÖ Always show HUD info
      hud.innerText = `Tick running\nSelected: ${BLOCKS[selectedBlockId].name}\nPlacing: ${allowPlacing ? 'ENABLED' : 'DISABLED'}`;

     if (inputState.place && allowPlacing) {
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(world.group.children, true);

  if (intersects.length > 0) {
    const hit = intersects[0];
    const pos = hit.point.clone().add(hit.face.normal).floor();
    const x = pos.x, y = pos.y, z = pos.z;

    if (world.get(x, y, z) === BLOCK_AIR) {
      world.set(x, y, z, selectedBlockId);
      world.updateMeshes();
    }
  }

  inputState.place = false;
        }
                
      

      if (inputState.break) {
        const x = Math.floor(player.pos.x);
        const y = Math.floor(player.pos.y - 1);
        const z = Math.floor(player.pos.z);
        world.set(x, y, z, BLOCK_AIR);
        world.updateMeshes();
        inputState.break = false;
      }
    }

    // --- Screenshot Download Logic ---
    function downloadScreenshot() {
      const canvas = renderer.domElement;
      const dataURL = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = 'shadow-craft-screenshot-' + new Date().toISOString().slice(0, 10) + '.png';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
    const downloadBtn = document.getElementById('download-screenshot-button');
    downloadBtn.addEventListener('click', downloadScreenshot);

    // Dummy save button handler
    const floatingSaveBtn = document.getElementById('floating-save-button');
    floatingSaveBtn.addEventListener('click', () => {
      alert('Saving is disabled in this version.');
    });
      
    
    function setupControls(player, camera){
      const btnToggleView = document.getElementById('btn-toggle-view');
      if (btnToggleView) {
        btnToggleView.addEventListener('touchstart', e => {
          e.preventDefault();
          thirdPerson = !thirdPerson;
        }, { passive: false });
      }
    
      document.addEventListener('click', ()=>{ if(window.matchMedia && window.matchMedia('(pointer: fine)').matches) document.body.requestPointerLock?.(); });
      function onMouseMove(e){ player.yaw -= e.movementX * 0.0025; player.pitch -= e.movementY * 0.0025; player.pitch = clamp(player.pitch, -Math.PI/2 + 0.01, Math.PI/2 - 0.01); }
      document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement === document.body) {
          window.addEventListener('mousemove', onMouseMove);
        } else {
          window.removeEventListener('mousemove', onMouseMove);
        }
      });
    
      window.addEventListener('keydown', e=>{
        if (e.code === 'KeyZ') {
          e.preventDefault(); // prevent browser refresh
          thirdPerson = !thirdPerson;
        }
        
        if(e.code==='KeyW') inputState.fw = 1;
        if(e.code==='KeyS') inputState.bk = 1;
        if(e.code==='KeyA') inputState.lt = 1;
        if(e.code==='KeyD') inputState.rt = 1;
        if(e.code==='ShiftLeft' || e.code==='ShiftRight') inputState.run = true;
        if(e.code==='Space') inputState.jump = true;
        if(e.code==='KeyE') inputState.place = true;
        if(e.code==='KeyQ') inputState.break = true;
        if(e.code==='KeyP'){ allowPlacing = !allowPlacing; rebuildHotbarUI(); }
        if (e.code === 'KeyI') {
          const panel = document.getElementById('inventory-panel');
          const isVisible = panel.style.display === 'block';
          panel.style.display = isVisible ? 'none' : 'block';
          if (!isVisible) rebuildInventoryUI();
        }
        
        if(e.key >= '1' && e.key <= '9'){ const n = parseInt(e.key); const ks = Object.keys(BLOCKS).map(x=>parseInt(x)); if(n-1 < ks.length){ selectedBlockId = ks[n-1]; rebuildHotbarUI(); } }
      });
      window.addEventListener('keyup', e=>{
        if(e.code==='KeyW') inputState.fw = 0;
        if(e.code==='KeyS') inputState.bk = 0;
        if(e.code==='KeyA') inputState.lt = 0;
        if(e.code==='KeyD') inputState.rt = 0;
        if(e.code==='ShiftLeft' || e.code==='ShiftRight') inputState.run = false;
        if(e.code==='Space') inputState.jump = false;
        if(e.code==='KeyE') inputState.place = false;
        if(e.code==='KeyQ') inputState.break = false;
      });

      // mobile joystick
      const joyLeft = document.getElementById('joy-left');
      const joyKnob = document.getElementById('joy-knob');
      if(joyLeft){
        joyLeft.addEventListener('touchstart', (e)=>{ e.preventDefault(); const t = e.changedTouches[0]; joystick.active=true; joystick.id=t.identifier; const rect = joyLeft.getBoundingClientRect(); joystick.startX = rect.left + rect.width/2; joystick.startY = rect.top + rect.height/2; joystick.dx = joystick.dy = 0; updateKnob(); }, {passive:false});
        joyLeft.addEventListener('touchmove', (e)=>{ if(!joystick.active) return; for(const t of Array.from(e.changedTouches)){ if(t.identifier === joystick.id){ joystick.dx = t.clientX - joystick.startX; joystick.dy = t.clientY - joystick.startY; const dist = Math.hypot(joystick.dx, joystick.dy); if(dist > MAX_JOY){ const s = MAX_JOY / dist; joystick.dx *= s; joystick.dy *= s; } updateKnob(); e.preventDefault(); return; } } }, {passive:false});
        joyLeft.addEventListener('touchend', (e)=>{ for(const t of Array.from(e.changedTouches)){ if(t.identifier === joystick.id){ joystick.active=false; joystick.id=null; joystick.dx=joystick.dy=0; updateKnob(); e.preventDefault(); return; } } }, {passive:false});
      }
      function updateKnob(){ if(!joyKnob || !joyLeft) return; const w = joyLeft.clientWidth, h = joyLeft.clientHeight; joyKnob.style.left = (50 + joystick.dx / w * 100) + '%'; joyKnob.style.top = (50 + joystick.dy / h * 100) + '%'; }
      window._mobileJoystick = joystick;

      // look area
      const lookArea = document.getElementById('look-area');
      let lookTouchId = null, lastLookX = 0, lastLookY = 0;
      if(lookArea){
        lookArea.addEventListener('touchstart', (e)=>{ const t = e.changedTouches[0]; lookTouchId = t.identifier; lastLookX = t.clientX; lastLookY = t.clientY; }, {passive:true});
        lookArea.addEventListener('touchmove', (e)=>{ if(lookTouchId === null) return; for(const t of Array.from(e.changedTouches)){ if(t.identifier === lookTouchId){ const dx = t.clientX - lastLookX, dy = t.clientY - lastLookY; player.yaw -= dx * 0.0035; player.pitch -= dy * 0.0035; player.pitch = clamp(player.pitch, -Math.PI/2 + 0.01, Math.PI/2 - 0.01); lastLookX = t.clientX; lastLookY = t.clientY; e.preventDefault(); return; } } }, {passive:false});
        lookArea.addEventListener('touchend', (e)=>{ for(const t of Array.from(e.changedTouches)){ if(t.identifier === lookTouchId){ lookTouchId = null; e.preventDefault(); return; } } }, {passive:false});
      }
      const leaveBtn = document.getElementById('leave-world-button');
      const confirmPopup = document.getElementById('confirm-leave');
      const confirmLeaveBtn = document.getElementById('confirm-leave-button');
      const cancelLeaveBtn = document.getElementById('cancel-leave-button');

      if (leaveBtn) {
        leaveBtn.addEventListener('click', () => {
          confirmPopup.style.display = 'flex';
        });
      }

      confirmLeaveBtn.addEventListener('click', () => {
        confirmPopup.style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
      });

      cancelLeaveBtn.addEventListener('click', () => {
        confirmPopup.style.display = 'none';
      });
      const tutorialBtn = document.getElementById('toggle-tutorial-button');
      const tutorialBox = document.getElementById('tutorial-box');

      tutorialBtn.addEventListener('click', () => {
        const isVisible = tutorialBox.style.display === 'block';
        tutorialBox.style.display = isVisible ? 'none' : 'block';
      });
    
      // on-screen buttons
      const btnPlace = document.getElementById('btn-place'), btnBreak = document.getElementById('btn-break'), btnJump = document.getElementById('btn-jump');
      const btnInventory = document.getElementById('btn-inventory');
      if (btnInventory) {
        btnInventory.addEventListener('touchstart', e => {
          e.preventDefault();
          const panel = document.getElementById('inventory-panel');
          const isVisible = panel.style.display === 'block';
          panel.style.display = isVisible ? 'none' : 'block';
          if (!isVisible) rebuildInventoryUI();
        }, { passive: false });
      }
      
      if(btnPlace){ btnPlace.addEventListener('touchstart', e=>{ e.preventDefault(); inputState.place = true; }, {passive:false}); btnPlace.addEventListener('touchend', e=>{ inputState.place = false; }, {passive:true}); }
      if(btnBreak){ btnBreak.addEventListener('touchstart', e=>{ e.preventDefault(); inputState.break = true; }, {passive:false}); btnBreak.addEventListener('touchend', e=>{ inputState.break = false; }, {passive:true}); }
      if(btnJump){ btnJump.addEventListener('touchstart', e=>{ e.preventDefault(); inputState.jump = true; }, {passive:false}); btnJump.addEventListener('touchend', e=>{ inputState.jump = false; }, {passive:true}); }
    }

    // ---------- Three.js bootstrap ----------
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(1); // lower pixel ratio for performance
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB);
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    scene.add(new THREE.AmbientLight(0xffffff, 0.25)); // softer ambient
    const sun = new THREE.DirectionalLight(0xffffff, 0.4); // dimmer sun
    sun.position.set(10, 30, 10);
    scene.add(sun);
    

    // ---------- World & player ----------
    const world = new VoxelWorld(WORLD_W, WORLD_H, WORLD_D, scene);
    const player = {
      pos: new THREE.Vector3(Math.floor(WORLD_W/2)+0.5, WORLD_H + PLAYER_EYE - 2, Math.floor(WORLD_D/2)+0.5),
      velocity: new THREE.Vector3(),
      yaw: 0, pitch: 0,
      speed: 4.0, jumpVel: 6.0, onGround: false
    };
    setupControls(player, camera);
    const playerModel = createPlayerModel();
    scene.add(playerModel);
    
    playerModel.position.set(player.pos.x, player.pos.y - 1.2, player.pos.z);
    
    // raycast helper
    const raycaster = new THREE.Raycaster();
    function getBlockTarget(){
      camera.updateMatrixWorld();
      raycaster.setFromCamera({x:0,y:0}, camera);
      const origin = raycaster.ray.origin.clone();
      const dir = raycaster.ray.direction.clone();
      const step = 0.12, maxDist = 8;
      const p = origin.clone();
      for(let t=0;t<maxDist;t+=step){
        p.addScaledVector(dir, step);
        const bx = Math.floor(p.x), by = Math.floor(p.y), bz = Math.floor(p.z);
        if(!inBounds(bx,by,bz)) continue;
        const bid = world.get(bx,by,bz);
        if(bid && bid !== BLOCK_AIR){
          const prev = p.clone().addScaledVector(dir, -step);
          return { block:{x:bx,y:by,z:bz,id:bid}, place:{x:Math.floor(prev.x), y:Math.floor(prev.y), z:Math.floor(prev.z)} };
        }
      }
      return null;
    }

    // improved collision: check AABB cells overlapped by player's box
    function isPlayerCollidingAt(pos){
      const half = 0.35;
      const minX = Math.floor(pos.x - half), maxX = Math.floor(pos.x + half);
      const minY = Math.floor(pos.y - PLAYER_EYE), maxY = Math.floor(pos.y - 0.01);
      const minZ = Math.floor(pos.z - half), maxZ = Math.floor(pos.z + half);
      for(let x = minX; x <= maxX; x++){
        for(let y = minY; y <= maxY; y++){
          for(let z = minZ; z <= maxZ; z++){
            if(!inBounds(x,y,z)) continue;
            if(world.get(x,y,z) !== BLOCK_AIR) return true;
          }
        }
      }
      return false;
    }

    // sub-stepped movement to avoid tunneling
    function movePlayerWithCollision(player, dt){
      const disp = player.velocity.clone().multiplyScalar(dt);
      const total = disp.length();
      const maxStep = 0.18;
      const steps = Math.max(1, Math.ceil(total / maxStep));
      const stepDisp = disp.clone().multiplyScalar(1/steps);
      for(let i=0;i<steps;i++){
        const candidate = player.pos.clone().add(stepDisp);
        if(!isPlayerCollidingAt(candidate)){
          player.pos.copy(candidate);
        } else {
          // simple response: try moving only horizontally then vertically separately
          // attempt horizontal only
          const horiz = new THREE.Vector3(stepDisp.x, 0, stepDisp.z);
          const candH = player.pos.clone().add(horiz);
          if(!isPlayerCollidingAt(candH)){
            player.pos.copy(candH);
            // keep vertical velocity for next steps
          } else {
            // blocked horizontally: stop horizontal velocity
            player.velocity.x = 0;
            player.velocity.z = 0;
          }
          // vertical attempt will continue in separate vertical stepping below
          break;
        }
      }
    }

    // helper to check placing overlap
    function wouldOverlapPlayer(tx,ty,tz, ppos){
      const half = 0.35;
      const pmin = { x: ppos.x - half, y: ppos.y - PLAYER_EYE - 0.1, z: ppos.z - half };
      const pmax = { x: ppos.x + half, y: ppos.y - 0.1 + 0.01, z: ppos.z + half };
      const bmin = { x: tx, y: ty, z: tz };
      const bmax = { x: tx + 1, y: ty + 1, z: tz + 1 };
      return (pmin.x < bmax.x && pmax.x > bmin.x) &&
             (pmin.y < bmax.y && pmax.y > bmin.y) &&
             (pmin.z < bmax.z && pmax.z > bmin.z);
    }

    // ---------- Main loop ----------
    let lastTime = performance.now();
    let placeTimer = 0, breakTimer = 0;
    const COOLDOWN_MS = 180;

    function animate(now){
      const dt = Math.min((now - lastTime)/1000, 0.05);
      lastTime = now;
      placeTimer = Math.max(0, placeTimer - dt*1000);
      breakTimer = Math.max(0, breakTimer - dt*1000);

      const js = window._mobileJoystick || { active:false, dx:0, dy:0 };
      let joyX = 0, joyY = 0;
      if(js.active){ joyX = js.dx / MAX_JOY; joyY = -js.dy / MAX_JOY; if(Math.abs(joyX) < JOY_DEADZONE) joyX = 0; if(Math.abs(joyY) < JOY_DEADZONE) joyY = 0; }
      const kbForward = inputState.fw ? 1 : (inputState.bk ? -1 : 0);
      const kbStrafe  = inputState.rt ? 1 : (inputState.lt ? -1 : 0);
      const forward = joyY !== 0 ? joyY : kbForward;
      const strafe  = joyX !== 0 ? joyX : kbStrafe;
      const speed = player.speed * (inputState.run ? 1.8 : 1.0);

      const sinY = Math.sin(player.yaw), cosY = Math.cos(player.yaw);
      let mvx = 0, mvz = 0;
      if(Math.abs(forward) > 0 || Math.abs(strafe) > 0){
        mvx = (strafe) * cosY + (forward) * sinY;
        mvz = (strafe) * -sinY + (forward) * cosY;
        const len = Math.hypot(mvx, mvz) || 1;
        mvx = (mvx / len) * speed;
        mvz = (mvz / len) * speed;
      }
      player.velocity.x = mvx;
      player.velocity.z = mvz;

      // apply gravity (if not overlapping)
      if(!isPlayerCollidingAt(player.pos)) player.velocity.y -= 12.0 * dt;

      // jump if standing
      if(isPlayerCollidingAt(new THREE.Vector3(player.pos.x, player.pos.y - 0.2, player.pos.z))){
        player.onGround = true;
        if(inputState.jump){
          player.velocity.y = player.jumpVel;
          player.onGround = false;
        }
      } else {
        player.onGround = false;
      }

      // move horizontally with sub-steps
      movePlayerWithCollision(player, dt);

      // vertical substeps
      const vyDisp = player.velocity.y * dt;
      const vsteps = Math.max(1, Math.ceil(Math.abs(vyDisp) / 0.12));
      const vyStep = vyDisp / vsteps;
      for(let i=0;i<vsteps;i++){
        const cand = player.pos.clone();
        cand.y += vyStep;
        if(!isPlayerCollidingAt(cand)){
          player.pos.y = cand.y;
        } else {
          player.velocity.y = 0;
          break;
        }
      }
      const eye = player.pos.clone();
      if (eye.y < PLAYER_EYE) eye.y = PLAYER_EYE;

      if (thirdPerson) {
        const behind = new THREE.Vector3(
          Math.sin(player.yaw) * -3,
          1.5,
          Math.cos(player.yaw) * -3
        );
        camera.position.copy(eye.clone().add(behind));
        camera.lookAt(eye);

        // Show and rotate player model
        playerModel.visible = true;
        playerModel.position.set(player.pos.x, player.pos.y - 1.2, player.pos.z);
        playerModel.rotation.y = player.yaw;
      } else {
        camera.position.set(eye.x, eye.y, eye.z);
        const lookDir = new THREE.Vector3(
          Math.sin(player.yaw) * Math.cos(player.pitch),
          Math.sin(player.pitch),
          Math.cos(player.yaw) * Math.cos(player.pitch)
        );
        camera.lookAt(eye.clone().add(lookDir));

        // Hide player model in first-person
        playerModel.visible = false;
      }
      
      // targeting
      const tgt = getBlockTarget();
      const cross = document.getElementById('crosshair');
      if(cross) cross.style.color = tgt ? '#ffd36b' : 'rgba(255,255,255,0.85)';
      if (!window._highlightMesh) {
        const highlightMat = new THREE.MeshBasicMaterial({ color: 0xffd36b, wireframe: true });
        const highlightGeom = new THREE.BoxGeometry(1.01, 1.01, 1.01);
        window._highlightMesh = new THREE.Mesh(highlightGeom, highlightMat);
        scene.add(window._highlightMesh);
      }

      if (tgt && tgt.block) {
        window._highlightMesh.visible = true;
        window._highlightMesh.position.set(
          tgt.block.x + 0.5,
          tgt.block.y + 0.5,
          tgt.block.z + 0.5
        );
      } else {
        window._highlightMesh.visible = false;
      }
      
      // breaking
      if(inputState.break && breakTimer <= 0 && tgt){
        const bx = tgt.block.x, by = tgt.block.y, bz = tgt.block.z;
        const bid = world.get(bx,by,bz);
        if(bid !== BLOCK_AIR){
          world.set(bx,by,bz, BLOCK_AIR);
          inventory[bid] = (inventory[bid] || 0) + 1;
          world.updateMeshes();
          rebuildHotbarUI();
          breakTimer = COOLDOWN_MS;
        }
        inputState.break = false;
      }

      // placing
      if(inputState.place && placeTimer <= 0 && tgt){
        if(!allowPlacing){
          const prev = hud.innerHTML;
          hud.innerHTML = 'Placing is disabled (press P to toggle).';
          setTimeout(()=> hud.innerHTML = prev, 900);
        } else {
          const tx = tgt.place.x, ty = tgt.place.y, tz = tgt.place.z;
          if(inBounds(tx,ty,tz) && world.get(tx,ty,tz) === BLOCK_AIR && !wouldOverlapPlayer(tx,ty,tz, player.pos)){
            if((inventory[selectedBlockId] || 0) > 0){
              world.set(tx,ty,tz, selectedBlockId);
              inventory[selectedBlockId] = Math.max(0, (inventory[selectedBlockId] || 0) - 1);
              world.updateMeshes();
              rebuildHotbarUI();
              placeTimer = COOLDOWN_MS;
            }
          }
        }
        inputState.place = false;
      }

      // sun rotation
      const t = performance.now() * 0.00012;
      sun.position.set(50*Math.sin(t), 50*Math.cos(t), 20*Math.cos(t*0.7));

      hud.innerHTML = `Pos: ${player.pos.x.toFixed(2)}, ${player.pos.y.toFixed(2)}, ${player.pos.z.toFixed(2)}<br>` +
                      `Selected: ${BLOCKS[selectedBlockId].name} (${inventory[selectedBlockId]||0})<br>` +
                      `Placing: ${allowPlacing ? 'ENABLED' : 'DISABLED'} (toggle: P)`;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // start
    rebuildHotbarUI();
    requestAnimationFrame(animate);
    camera.position.set(player.pos.x, player.pos.y, player.pos.z);
    camera.lookAt(player.pos.x + Math.sin(player.yaw), player.pos.y + Math.sin(player.pitch), player.pos.z + Math.cos(player.yaw));
    document.getElementById('hud').innerText = 'Loaded. Click to pointer-lock and play. Flatter terrain and collision fixes applied.';
    animate(performance.now());
    </script>
</body>
</html>
